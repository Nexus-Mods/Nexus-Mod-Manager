<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Antlr3-2.Runtime.DotNet20</name>
    </assembly>
    <members>
        <member name="P:Antlr.Runtime.IToken.Text">
            <summary>Get the text of the token</summary> 
        </member>
        <member name="P:Antlr.Runtime.IToken.Line">
            <summary>The line number on which this token was matched; line=1..n</summary> 
        </member>
        <member name="P:Antlr.Runtime.IToken.CharPositionInLine">
            <summary>The index of the first character relative to the beginning of the line 0..n-1</summary> 
        </member>
        <member name="P:Antlr.Runtime.IToken.TokenIndex">
            <summary>
            An index from 0..n-1 of the token object in the input stream.
            This must be valid in order to use the ANTLRWorks debugger.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.IToken.InputStream">
            <summary>
            From what character stream was this token created?  You don't have to
            implement but it's nice to know where a Token comes from if you have
            include files etc... on the input.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Debug.IDebugEventListener">
            <summary>All debugging events that a recognizer can trigger.</summary>
            
              <remarks>
              I did not create a separate AST debugging interface as it would create
              lots of extra classes and DebugParser has a dbg var defined, which makes
              it hard to change to ASTDebugEventListener.  I looked hard at this issue
              and it is easier to understand as one monolithic event interface for all
              possible events.  Hopefully, adding ST debugging stuff won't be bad.  Leave
              for future. 4/26/2006.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.EnterRule(System.String,System.String)">
            <summary>
            The parser has just entered a rule.  No decision has been made about
            which alt is predicted.  This is fired AFTER init actions have been
            executed.  Attributes are defined and available etc...
            The grammarFileName allows composite grammars to jump around among
            multiple grammar files.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.EnterAlt(System.Int32)">
            <summary>
            Because rules can have lots of alternatives, it is very useful to
            know which alt you are entering.  This is 1..n for n alts.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.ExitRule(System.String,System.String)">
            <summary>
            This is the last thing executed before leaving a rule.  It is
            executed even if an exception is thrown.  This is triggered after
            error reporting and recovery have occurred (unless the exception is
            not caught in this rule).  This implies an "exitAlt" event.
            The grammarFileName allows composite grammars to jump around among
            multiple grammar files.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.EnterSubRule(System.Int32)">
            <summary>Track entry into any (...) subrule other EBNF construct</summary> 
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.EnterDecision(System.Int32,System.Boolean)">
            <summary>
            Every decision, fixed k or arbitrary, has an enter/exit event
            so that a GUI can easily track what LT/consume events are
            associated with prediction.  You will see a single enter/exit
            subrule but multiple enter/exit decision events, one for each
            loop iteration.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.ConsumeToken(Antlr.Runtime.IToken)">
            <summary>
            An input token was consumed; matched by any kind of element.
            Trigger after the token was matched by things like match(), matchAny().
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.ConsumeHiddenToken(Antlr.Runtime.IToken)">
            <summary>
            An off-channel input token was consumed.
            Trigger after the token was matched by things like match(), matchAny().
            (unless of course the hidden token is first stuff in the input stream).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.LT(System.Int32,Antlr.Runtime.IToken)">
            <summary>
            Somebody (anybody) looked ahead.  Note that this actually gets
            triggered by both LA and LT calls.  The debugger will want to know
            which Token object was examined.  Like consumeToken, this indicates
            what token was seen at that depth.  A remote debugger cannot look
            ahead into a file it doesn't have so LT events must pass the token
            even if the info is redundant.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.Mark(System.Int32)">
            <summary>
            The parser is going to look arbitrarily ahead; mark this location,
            the token stream's marker is sent in case you need it.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.Rewind(System.Int32)">
            <summary>
            After an arbitrairly long lookahead as with a cyclic DFA (or with
            any backtrack), this informs the debugger that stream should be
            rewound to the position associated with marker.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.Rewind">
            <summary>
            Rewind to the input position of the last marker.
            Used currently only after a cyclic DFA and just
            before starting a sem/syn predicate to get the
            input position back to the start of the decision.
            Do not "pop" the marker off the state.  mark(i)
            and rewind(i) should balance still.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.Location(System.Int32,System.Int32)">
            <summary>
              To watch a parser move through the grammar, the parser needs to
              inform the debugger what line/charPos it is passing in the grammar.
              For now, this does not know how to switch from one grammar to the
              other and back for island grammars etc...
              </summary>
            
              <remarks>
              This should also allow breakpoints because the debugger can stop
              the parser whenever it hits this line/pos.
              </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Antlr.Runtime.Debug.IDebugEventListener.RecognitionException(Antlr.Runtime.RecognitionException)" -->
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.BeginResync">
            <summary>
            Indicates the recognizer is about to consume tokens to resynchronize
            the parser.  Any consume events from here until the recovered event
            are not part of the parse--they are dead tokens.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.EndResync">
            <summary>
            Indicates that the recognizer has finished consuming tokens in order
            to resychronize.  There may be multiple beginResync/endResync pairs
            before the recognizer comes out of errorRecovery mode (in which
            multiple errors are suppressed).  This will be useful
            in a gui where you want to probably grey out tokens that are consumed
            but not matched to anything in grammar.  Anything between
            a beginResync/endResync pair was tossed out by the parser.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.SemanticPredicate(System.Boolean,System.String)">
            <summary>A semantic predicate was evaluate with this result and action text</summary> 
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.Commence">
            <summary>
            Announce that parsing has begun.  Not technically useful except for
            sending events over a socket.  A GUI for example will launch a thread
            to connect and communicate with a remote parser.  The thread will want
            to notify the GUI when a connection is made.  ANTLR parsers
            trigger this upon entry to the first rule (the ruleLevel is used to
            figure this out).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.Terminate">
            <summary>
            Parsing is over; successfully or not.  Mostly useful for telling
            remote debugging listeners that it's time to quit.  When the rule
            invocation level goes to zero at the end of a rule, we are done
            parsing.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.ConsumeNode(System.Object)">
            <summary>
              Input for a tree parser is an AST, but we know nothing for sure
              about a node except its type and text (obtained from the adaptor).
              This is the analog of the consumeToken method.  Again, the ID is
              the hashCode usually of the node so it only works if hashCode is
              not implemented.  If the type is UP or DOWN, then
              the ID is not really meaningful as it's fixed--there is
              just one UP node and one DOWN navigation node.
              </summary>
            
              <param name="t" />
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.LT(System.Int32,System.Object)">
            <summary>
            The tree parser lookedahead.  If the type is UP or DOWN,
            then the ID is not really meaningful as it's fixed--there is
            just one UP node and one DOWN navigation node.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.NilNode(System.Object)">
            <summary>
              A nil was created (even nil nodes have a unique ID...
              they are not "null" per se).  As of 4/28/2006, this
              seems to be uniquely triggered when starting a new subtree
              such as when entering a subrule in automatic mode and when
              building a tree in rewrite mode.
              </summary>
            
              <remarks>
              If you are receiving this event over a socket via
              RemoteDebugEventSocketListener then only t.ID is set.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.ErrorNode(System.Object)">
            <summary>
              Upon syntax error, recognizers bracket the error with an error node
              if they are building ASTs.
              </summary>
            
              <param name="t"/>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.CreateNode(System.Object)">
            <summary>Announce a new node built from token elements such as type etc...</summary>
            
             <remarks>
             If you are receiving this event over a socket via
             RemoteDebugEventSocketListener then only t.ID, type, text are
             set.
             </remarks>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.CreateNode(System.Object,Antlr.Runtime.IToken)">
            <summary>Announce a new node built from an existing token.</summary>
            
              <remarks>
              If you are receiving this event over a socket via
              RemoteDebugEventSocketListener then only node.ID and token.tokenIndex
              are set.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.BecomeRoot(System.Object,System.Object)">
            <summary>Make a node the new root of an existing root.  See</summary>
            
              <remarks>
              Note: the newRootID parameter is possibly different
              than the TreeAdaptor.becomeRoot() newRoot parameter.
              In our case, it will always be the result of calling
              TreeAdaptor.becomeRoot() and not root_n or whatever.
            
              The listener should assume that this event occurs
              only when the current subrule (or rule) subtree is
              being reset to newRootID.
             
              If you are receiving this event over a socket via
              RemoteDebugEventSocketListener then only IDs are set.
              </remarks>
            
              <seealso cref="!:Antlr.Runtime.Tree.TreeAdaptor.becomeRoot()"/>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.AddChild(System.Object,System.Object)">
            <summary>Make childID a child of rootID.</summary>
            
              <remarks>
              If you are receiving this event over a socket via
              RemoteDebugEventSocketListener then only IDs are set.
              </remarks>
            
              <seealso cref="!:Antlr.Runtime.Tree.TreeAdaptor.addChild()"/>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.SetTokenBoundaries(System.Object,System.Int32,System.Int32)">
            <summary>Set the token start/stop token index for a subtree root or node.</summary>
            
              <remarks>
              If you are receiving this event over a socket via
              RemoteDebugEventSocketListener then only t.ID is set.
              </remarks>
        </member>
        <member name="T:Antlr.Runtime.Tree.ITreeNodeStream">
            <summary>A stream of tree nodes, accessing nodes from a tree of some kind</summary> 
        </member>
        <member name="T:Antlr.Runtime.IIntStream">
            <summary>
            A simple stream of integers. This is useful when all we care about is the char
            or token type sequence (such as for interpretation).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.LA(System.Int32)">
            <summary>
            Get int at current input pointer + i ahead (where i=1 is next int)
            Negative indexes are allowed.  LA(-1) is previous token (token just matched).
            LA(-i) where i is before first token should yield -1, invalid char or EOF.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Mark">
            <summary>Tell the stream to start buffering if it hasn't already.</summary>
            <remarks>
            Executing Rewind(Mark()) on a stream should not affect the input position.
            The Lexer tracks line/col info as well as input index so its markers are
            not pure input indexes.  Same for tree node streams.													*/
            </remarks>
            <returns>Return a marker that can be passed to 
            <see cref="M:Antlr.Runtime.IIntStream.Rewind(System.Int32)"/> to return to the current position. 
            This could be the current input position, a value return from 
            <see cref="P:Antlr.Runtime.IIntStream.Index"/>, or some other marker.</returns>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Rewind(System.Int32)">
            <summary>
            Resets the stream so that the next call to 
            <see cref="P:Antlr.Runtime.IIntStream.Index"/> would  return marker.
            </summary>
            <remarks>
            The marker will usually be <see cref="P:Antlr.Runtime.IIntStream.Index"/> but 
            it doesn't have to be.  It's just a marker to indicate what 
            state the stream was in.  This is essentially calling 
            <see cref="M:Antlr.Runtime.IIntStream.Release(System.Int32)"/> and <see cref="M:Antlr.Runtime.IIntStream.Seek(System.Int32)"/>.
            If there are other markers created after the specified marker, 
            this routine must unroll them like a stack.  Assumes the state the 
            stream was in when this marker was created.
            </remarks>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Rewind">
            <summary>
            Rewind to the input position of the last marker.
            </summary>
            <remarks>
            Used currently only after a cyclic DFA and just before starting 
            a sem/syn predicate to get the input position back to the start 
            of the decision. Do not "pop" the marker off the state.  Mark(i) 
            and Rewind(i) should balance still. It is like invoking 
            Rewind(last marker) but it should not "pop" the marker off.  
            It's like Seek(last marker's input position).
            </remarks>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Release(System.Int32)">
            <summary>
            You may want to commit to a backtrack but don't want to force the
            stream to keep bookkeeping objects around for a marker that is
            no longer necessary.  This will have the same behavior as
            <see cref="M:Antlr.Runtime.IIntStream.Rewind(System.Int32)"/> except it releases resources without 
            the backward seek.
            </summary>
            <remarks>
            This must throw away resources for all markers back to the marker
            argument. So if you're nested 5 levels of Mark(), and then Release(2)
            you have to release resources for depths 2..5.
            </remarks>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Seek(System.Int32)">
            <summary>
            Set the input cursor to the position indicated by index.  This is
            normally used to seek ahead in the input stream.
            </summary>
            <remarks>
            No buffering is required to do this unless you know your stream 
            will use seek to move backwards such as when backtracking.
            
            This is different from rewind in its multi-directional requirement 
            and in that its argument is strictly an input cursor (index).
            
            For char streams, seeking forward must update the stream state such
            as line number.  For seeking backwards, you will be presumably
            backtracking using the 
            <see cref="M:Antlr.Runtime.IIntStream.Mark"/>/<see cref="M:Antlr.Runtime.IIntStream.Rewind(System.Int32)"/> 
            mechanism that restores state and so this method does not need to 
            update state when seeking backwards.
            
            Currently, this method is only used for efficient backtracking using
            memoization, but in the future it may be used for incremental parsing.
            
            The index is 0..n-1. A seek to position i means that LA(1) will return 
            the ith symbol.  So, seeking to 0 means LA(1) will return the first 
            element in the stream.
            </remarks>
        </member>
        <member name="P:Antlr.Runtime.IIntStream.Index">
            <summary>
            Return the current input symbol index 0..n where n indicates the 
            last symbol has been read. The index is the symbol about to be
            read not the most recently read symbol.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.IIntStream.Count">
            <summary>Returns the size of the entire stream.</summary>
            <remarks>
            Only makes sense for streams that buffer everything up probably, 
            but might be useful to display the entire stream or for testing.
            This value includes a single EOF.
            </remarks>
        </member>
        <member name="P:Antlr.Runtime.IIntStream.SourceName">
            <summary>
            Where are you getting symbols from?  Normally, implementations will
            pass the buck all the way to the lexer who can ask its input stream
            for the file name or whatever.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeNodeStream.LT(System.Int32)">
            <summary>
              Get tree node at current input pointer + i ahead where i=1 is next node.
              i&lt;0 indicates nodes in the past.  So LT(-1) is previous node, but
              implementations are not required to provide results for k &lt; -1.
              LT(0) is undefined.  For i&gt;=n, return null.
              Return null for LT(0) and any index that results in an absolute address
              that is negative.
              </summary>
            
              <remarks>
              This is analogus to the LT() method of the TokenStream, but this
              returns a tree node instead of a token.  Makes code gen identical
              for both parser and tree grammars. :)
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeNodeStream.ToString(System.Object,System.Object)">
            <summary>
            Return the text of all nodes from start to stop, inclusive.
            If the stream does not buffer all the nodes then it can still
            walk recursively from start until stop.  You can always return
            null or "" too, but users should not access $ruleLabel.text in
            an action of course in that case.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeNodeStream.ReplaceChildren(System.Object,System.Int32,System.Int32,System.Object)">
            <summary>
              Replace from start to stop child index of parent with t, which might
              be a list.  Number of children may be different
              after this call.  The stream is notified because it is walking the
              tree and might need to know you are monkeying with the underlying
              tree.  Also, it might be able to modify the node stream to avoid
              restreaming for future phases.
              </summary>
            
              <remarks>
              If parent is null, don't do anything; must be at root of overall tree.
              Can't replace whatever points to the parent externally.  Do nothing.
              </remarks>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITreeNodeStream.Item(System.Int32)">
            <summary>
            Get a tree node at an absolute index i; 0..n-1.
            If you don't want to buffer up nodes, then this method makes no
            sense for you.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITreeNodeStream.TreeSource">
            <summary>
            Where is this stream pulling nodes from?  This is not the name, but
            the object that provides node objects.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITreeNodeStream.TokenStream">
            <summary>
            If the tree associated with this stream was created from a TokenStream,
            you can specify it here.  Used to do rule $text attribute in tree
            parser.  Optional unless you use tree parser rule text attribute
            or output=template and rewrite=true options.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITreeNodeStream.TreeAdaptor">
            <summary>
            What adaptor can tell me how to interpret/navigate nodes and
            trees.  E.g., get text of a node.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITreeNodeStream.UniqueNavigationNodes">
            <summary>
            As we flatten the tree, we use UP, DOWN nodes to represent
            the tree structure.  When debugging we need unique nodes
            so we have to instantiate new ones.  When doing normal tree
            parsing, it's slow and a waste of memory to create unique
            navigation nodes.  Default should be false;
            </summary>
        </member>
        <member name="T:Antlr.Runtime.RecognitionException">
            <summary>The root of the ANTLR exception hierarchy.</summary>
            
              <remarks>
              To avoid English-only error messages and to generally make things
              as flexible as possible, these exceptions are not created with strings,
              but rather the information necessary to generate an error.  Then
              the various reporting methods in Parser and Lexer can be overridden
              to generate a localized error message.  For example, MismatchedToken
              exceptions are built with the expected token type.
              So, don't expect getMessage() to return anything.
            
              Note that as of Java 1.4, you can access the stack trace, which means
              that you can compute the complete trace of rules from the start symbol.
              This gives you considerable context information with which to generate
              useful error messages.
            
              ANTLR generates code that throws exceptions upon recognition error and
              also generates code to catch these exceptions in each rule.  If you
              want to quit upon first error, you can turn off the automatic error
              handling mechanism using rulecatch action, but you still need to
              override methods mismatch and recoverFromMismatchSet.
            
              In general, the recognition exceptions can track where in a grammar a
              problem occurred and/or what was the expected input.  While the parser
              knows its state (such as current input symbol and line info) that
              state can change before the exception is reported so current token index
              is computed and stored at exception time.  From this info, you can
              perhaps print an entire line of input not just a single token, for example.
              Better to just say the recognizer had a problem and then let the parser
              figure out a fancy report.
              </remarks>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._input">
            <summary>What input stream did the error occur in?</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._index">
            <summary>What is index of token/char were we looking at when the error occurred?</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._token">
            <summary>
            The current Token when an error occurred.  Since not all streams
            can retrieve the ith Token, we have to track the Token object.
            For parsers.  Even when it's a tree parser, token might be set.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._node">
            <summary>
            If this is a tree parser exception, node is set to the node with
            the problem.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._c">
            <summary>The current char when an error occurred. For lexers.</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._line">
            <summary>
            Track the line (1-based) at which the error occurred in case this is
            generated from a lexer.  We need to track this since the
            unexpected char doesn't carry the line info.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._charPositionInLine">
            <summary>
            The 0-based index into the line where the error occurred.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._approximateLineInfo">
            <summary>
            If you are parsing a tree node stream, you will encounter som
            imaginary nodes w/o line/col info.  We now search backwards looking
            for most recent token with line/col info, but notify getErrorHeader()
            that info is approximate.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.RecognitionException.#ctor">
            <summary>Used for remote debugger deserialization</summary> 
        </member>
        <member name="P:Antlr.Runtime.RecognitionException.UnexpectedType">
            <summary>Return the token type or char of the unexpected input element</summary> 
        </member>
        <member name="T:Antlr.Runtime.Misc.FastQueue`1">
            A queue that can dequeue and get(i) in O(1) and grow arbitrarily large.
              A linked list is fast at dequeue but slow at get(i).  An array is
              the reverse.  This is O(1) for both operations.
            
              List grows until you dequeue last element at end of buffer. Then
              it resets to start filling at 0 again.  If adds/removes are balanced, the
              buffer will not grow too large.
            
              No iterator stuff as that's not how we'll use it.
        </member>
        <member name="F:Antlr.Runtime.Misc.FastQueue`1._data">
            <summary>dynamically-sized buffer of elements</summary> 
        </member>
        <member name="F:Antlr.Runtime.Misc.FastQueue`1._p">
            <summary>index of next element to fill</summary> 
        </member>
        <member name="M:Antlr.Runtime.Misc.FastQueue`1.Dequeue">
            <summary>Get and remove first element in queue</summary> 
        </member>
        <member name="M:Antlr.Runtime.Misc.FastQueue`1.ToString">
            <summary>Return string of current buffer contents; non-destructive</summary> 
        </member>
        <member name="P:Antlr.Runtime.Misc.FastQueue`1.Range">
            <summary>
            How deep have we gone?
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Misc.FastQueue`1.Item(System.Int32)">
            <summary>
            Return element i elements ahead of current element.  i==0 gets
            current element.  This is not an absolute index into the data list
            since p defines the start of the real list.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.RewriteRuleElementStream">
            <summary>
              A generic list of elements tracked in an alternative to be used in
              a -&gt; rewrite rule.  We need to subclass to fill in the next() method,
              which returns either an AST node wrapped around a token payload or
              an existing subtree.
              </summary>
            
              <remarks>
              Once you start next()ing, do not try to add more elements.  It will
              break the cursor tracking I believe.
            
              TODO: add mechanism to detect/puke on modification after reading from stream
              </remarks>
            
              <see cref="T:Antlr.Runtime.Tree.RewriteRuleSubtreeStream"/>
              <see cref="T:Antlr.Runtime.Tree.RewriteRuleTokenStream"/>
        </member>
        <member name="F:Antlr.Runtime.Tree.RewriteRuleElementStream.cursor">
            <summary>
            Cursor 0..n-1.  If singleElement!=null, cursor is 0 until you next(),
            which bumps it to 1 meaning no more elements.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Antlr.Runtime.Tree.RewriteRuleElementStream.singleElement" -->
        <!-- Badly formed XML comment ignored for member "F:Antlr.Runtime.Tree.RewriteRuleElementStream.elements" -->
        <!-- Badly formed XML comment ignored for member "F:Antlr.Runtime.Tree.RewriteRuleElementStream.dirty" -->
        <!-- Badly formed XML comment ignored for member "F:Antlr.Runtime.Tree.RewriteRuleElementStream.elementDescription" -->
        <member name="M:Antlr.Runtime.Tree.RewriteRuleElementStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Object)">
            <summary>Create a stream with one element</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleElementStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Collections.IList)">
            <summary>Create a stream, but feed off an existing list</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleElementStream.Reset">
            <summary>
            Reset the condition of this stream so that it appears we have
            not consumed any of its elements.  Elements themselves are untouched.
            Once we reset the stream, any future use will need duplicates.  Set
            the dirty bit.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleElementStream.NextTree">
            <summary>
            Return the next element in the stream.  If out of elements, throw
            an exception unless size()==1.  If size is 1, then return elements[0].
            Return a duplicate node/subtree if stream is out of elements and
            size==1.  If we've already used the element, dup (dirty bit set).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleElementStream.NextCore">
            <summary>
            Do the work of getting the next element, making sure that it's
            a tree node or subtree.  Deal with the optimization of single-
            element list versus list of size > 1.  Throw an exception
            if the stream is empty or we're out of elements and size>1.
            protected so you can override in a subclass if necessary.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleElementStream.Dup(System.Object)">
            <summary>
             When constructing trees, sometimes we need to dup a token or AST
            	subtree.  Dup'ing a token means just creating another AST node
             around it.  For trees, you must call the adaptor.dupTree() unless
             the element is for a tree root; then it must be a node dup.
             </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleElementStream.ToTree(System.Object)">
            <summary>
            Ensure stream emits trees; tokens must be converted to AST nodes.
            AST nodes can be passed through unmolested.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleSubtreeStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Object)">
            <summary>Create a stream with one element</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleSubtreeStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Collections.IList)">
            <summary>Create a stream, but feed off an existing list</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleSubtreeStream.NextNode">
            <summary>
              Treat next element as a single node even if it's a subtree.
              This is used instead of next() when the result has to be a
              tree root node.  Also prevents us from duplicating recently-added
              children; e.g., ^(type ID)+ adds ID to type and then 2nd iteration
              must dup the type node, but ID has been added.
              </summary>
            
              <remarks>
              Referencing a rule result twice is ok; dup entire tree as
              we can't be adding trees as root; e.g., expr expr.
            
              Hideous code duplication here with super.next().  Can't think of
              a proper way to refactor.  This needs to always call dup node
              and super.next() doesn't know which to call: dup node or dup tree.
              </remarks>
        </member>
        <member name="T:Antlr.Runtime.FailedPredicateException">
            <summary>
            A semantic predicate failed during validation.  Validation of predicates
            occurs when normally parsing the alternative just like matching a token.
            Disambiguating predicate evaluation occurs when we hoist a predicate into
            a prediction decision.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.UnbufferedTokenStream">
            A token stream that pulls tokens from the code source on-demand and
              without tracking a complete buffer of the tokens. This stream buffers
              the minimum number of tokens possible.  It's the same as
              OnDemandTokenStream except that OnDemandTokenStream buffers all tokens.
            
              You can't use this stream if you pass whitespace or other off-channel
              tokens to the parser. The stream can't ignore off-channel tokens.
             
              You can only look backwards 1 token: LT(-1).
            
              Use this when you need to read from a socket or other infinite stream.
            
              @see BufferedTokenStream
              @see CommonTokenStream
        </member>
        <member name="T:Antlr.Runtime.Misc.LookaheadStream`1">
            <summary>
            A lookahead queue that knows how to mark/release locations
            in the buffer for backtracking purposes. Any markers force the FastQueue
            superclass to keep all tokens until no more markers; then can reset
            to avoid growing a huge buffer.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Misc.LookaheadStream`1._currentElementIndex">
            Absolute token index. It's the index of the symbol about to be
            read via LT(1). Goes from 0 to numtokens.
        </member>
        <member name="F:Antlr.Runtime.Misc.LookaheadStream`1._eof">
            Track object returned by nextElement upon end of stream;
            Return it later when they ask for LT passed end of input.
        </member>
        <member name="F:Antlr.Runtime.Misc.LookaheadStream`1._lastMarker">
            <summary>Track the last mark() call result value for use in rewind().</summary> 
        </member>
        <member name="F:Antlr.Runtime.Misc.LookaheadStream`1._markDepth">
            <summary>tracks how deep mark() calls are nested</summary> 
        </member>
        <member name="M:Antlr.Runtime.Misc.LookaheadStream`1.NextElement">
            <summary>
            Implement nextElement to supply a stream of elements to this
            lookahead buffer.  Return eof upon end of the stream we're pulling from.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Misc.LookaheadStream`1.Dequeue">
            <summary>Get and remove first element in queue; override FastQueue.remove()</summary> 
        </member>
        <member name="M:Antlr.Runtime.Misc.LookaheadStream`1.Consume">
            <summary>Make sure we have at least one element to remove, even if EOF</summary> 
        </member>
        <member name="M:Antlr.Runtime.Misc.LookaheadStream`1.SyncAhead(System.Int32)">
            <summary>
            Make sure we have 'need' elements from current position p. Last valid
            p index is data.size()-1.  p+need-1 is the data index 'need' elements
            ahead.  If we need 1 element, (p+1-1)==p must be &lt; data.size().
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Misc.LookaheadStream`1.Fill(System.Int32)">
            <summary>add n elements to buffer</summary> 
        </member>
        <member name="M:Antlr.Runtime.Misc.LookaheadStream`1.Seek(System.Int32)">
            <summary>
            Seek to a 0-indexed position within data buffer.  Can't handle
            case where you seek beyond end of existing buffer.  Normally used
            to seek backwards in the buffer. Does not force loading of nodes.
            Doesn't see to absolute position in input stream since this stream
            is unbuffered. Seeks only into our moving window of elements.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Misc.LookaheadStream`1.Count">
            <summary>Size of entire stream is unknown; we only know buffer size from FastQueue</summary> 
        </member>
        <member name="T:Antlr.Runtime.ITokenStream">
            <summary>A stream of tokens accessing tokens from a TokenSource</summary> 
        </member>
        <member name="M:Antlr.Runtime.ITokenStream.LT(System.Int32)">
            <summary>Get Token at current input pointer + i ahead where i=1 is next Token.
            i&lt;0 indicates tokens in the past.  So -1 is previous token and -2 is
            two tokens ago. LT(0) is undefined.  For i&gt;=n, return Token.EOFToken.
            Return null for LT(0) and any index that results in an absolute address
            that is negative.</summary>
        </member>
        <member name="M:Antlr.Runtime.ITokenStream.Get(System.Int32)">
            <summary>
            Get a token at an absolute index i; 0..n-1.  This is really only
            needed for profiling and debugging and token stream rewriting.
            If you don't want to buffer up tokens, then this method makes no
            sense for you.  Naturally you can't use the rewrite stream feature.
            I believe DebugTokenStream can easily be altered to not use
            this method, removing the dependency.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ITokenStream.ToString(System.Int32,System.Int32)">
            <summary>
            Return the text of all tokens from start to stop, inclusive.
            If the stream does not buffer all the tokens then it can just
            return "" or null;  Users should not access $ruleLabel.text in
            an action of course in that case.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ITokenStream.ToString(Antlr.Runtime.IToken,Antlr.Runtime.IToken)">
            <summary>
            Because the user is not required to use a token with an index stored
            in it, we must provide a means for two token objects themselves to
            indicate the start/end location.  Most often this will just delegate
            to the other toString(int,int).  This is also parallel with
            the TreeNodeStream.toString(Object,Object).
            </summary>
        </member>
        <member name="P:Antlr.Runtime.ITokenStream.Range">
            <summary>
            How far ahead has the stream been asked to look?  The return
            value is a valid index from 0..n-1.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.ITokenStream.TokenSource">
            <summary>
            Where is this stream pulling tokens from?  This is not the name, but
            the object that provides Token objects.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.UnbufferedTokenStream.channel">
            Skip tokens on any channel but this one; this is how we skip whitespace... 
        </member>
        <member name="T:Antlr.Runtime.MissingTokenException">
            <summary>
            We were expecting a token but it's not found.  The current token
            is actually what we wanted next.  Used for tree node errors too.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.MismatchedTokenException">
            <summary>A mismatched char or Token or tree node</summary> 
        </member>
        <member name="T:Antlr.Runtime.ICharStream">
            <summary>A source of characters for an ANTLR lexer</summary> 
        </member>
        <member name="M:Antlr.Runtime.ICharStream.Substring(System.Int32,System.Int32)">
            <summary>
            For infinite streams, you don't need this; primarily I'm providing
            a useful interface for action code.  Just make sure actions don't
            use this on streams that don't support it.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ICharStream.LT(System.Int32)">
            <summary>
            Get the ith character of lookahead.  This is the same usually as
            LA(i).  This will be used for labels in the generated
            lexer code.  I'd prefer to return a char here type-wise, but it's
            probably better to be 32-bit clean and be consistent with LA.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.ICharStream.Line">
            <summary>ANTLR tracks the line information automatically</summary> 
            <summary>Because this stream can rewind, we need to be able to reset the line</summary> 
        </member>
        <member name="P:Antlr.Runtime.ICharStream.CharPositionInLine">
            <summary>The index of the character relative to the beginning of the line 0..n-1</summary> 
        </member>
        <member name="T:Antlr.Runtime.Debug.BlankDebugEventListener">
            <summary>
            A blank listener that does nothing; useful for real classes so
            they don't have to have lots of blank methods and are less
            sensitive to updates to debug interface.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.CommonTreeAdaptor">
            <summary>
              A TreeAdaptor that works with any Tree implementation.  It provides
              really just factory methods; all the work is done by BaseTreeAdaptor.
              If you would like to have different tokens created than ClassicToken
              objects, you need to override this and then set the parser tree adaptor to
              use your subclass.
              </summary>
            
              <remarks>
              To get your parser to build nodes of a different type, override
              create(Token), errorNode(), and to be safe, YourTreeClass.dupNode().
              dupNode is called to duplicate nodes during rewrite operations.
              </remarks>
        </member>
        <member name="T:Antlr.Runtime.Tree.BaseTreeAdaptor">
            <summary>A TreeAdaptor that works with any Tree implementation.</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.ITreeAdaptor">
            <summary>
              How to create and navigate trees.  Rather than have a separate factory
              and adaptor, I've merged them.  Makes sense to encapsulate.
              </summary>
            
              <remarks>
              This takes the place of the tree construction code generated in the
              generated code in 2.x and the ASTFactory.
            
              I do not need to know the type of a tree at all so they are all
              generic Objects.  This may increase the amount of typecasting needed. :(
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.Create(Antlr.Runtime.IToken)">
            <summary>
              Create a tree node from Token object; for CommonTree type trees,
              then the token just becomes the payload.  This is the most
              common create call.
              </summary>
            
              <remarks>
              Override if you want another kind of node to be built.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.DupNode(System.Object)">
            <summary>Duplicate a single tree node.</summary>
            <remarks>Override if you want another kind of node to be built.</remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.DupTree(System.Object)">
            <summary>Duplicate tree recursively, using dupNode() for each node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.Nil">
            <summary>
            Return a nil node (an empty but non-null node) that can hold
            a list of element as the children.  If you want a flat tree (a list)
            use "t=adaptor.nil(); t.addChild(x); t.addChild(y);"
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Antlr.Runtime.Tree.ITreeAdaptor.ErrorNode(Antlr.Runtime.ITokenStream,Antlr.Runtime.IToken,Antlr.Runtime.IToken,Antlr.Runtime.RecognitionException)" -->
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.IsNil(System.Object)">
            <summary>Is tree considered a nil node used to make lists of child nodes?</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.AddChild(System.Object,System.Object)">
            <summary>
            Add a child to the tree t.  If child is a flat tree (a list), make all
            in list children of t.  Warning: if t has no children, but child does
            and child isNil then you can decide it is ok to move children to t via
            t.children = child.children; i.e., without copying the array.  Just
            make sure that this is consistent with have the user will build
            ASTs.  Do nothing if t or child is null.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.BecomeRoot(System.Object,System.Object)">
            <summary>
              If oldRoot is a nil root, just copy or move the children to newRoot.
              If not a nil root, make oldRoot a child of newRoot.
              </summary>
            
              <remarks>
                old=^(nil a b c), new=r yields ^(r a b c)
                old=^(a b c), new=r yields ^(r ^(a b c))
            
              If newRoot is a nil-rooted single child tree, use the single
              child as the new root node.
            
                old=^(nil a b c), new=^(nil r) yields ^(r a b c)
                old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
            
              If oldRoot was null, it's ok, just return newRoot (even if isNil).
            
                old=null, new=r yields r
                old=null, new=^(nil r) yields ^(nil r)
            
              Return newRoot.  Throw an exception if newRoot is not a
              simple node or nil root with a single child node--it must be a root
              node.  If newRoot is ^(nil x) return x as newRoot.
            
              Be advised that it's ok for newRoot to point at oldRoot's
              children; i.e., you don't have to copy the list.  We are
              constructing these nodes so we should have this control for
              efficiency.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.RulePostProcessing(System.Object)">
            <summary>
              Given the root of the subtree created for this rule, post process
              it to do any simplifications or whatever you want.  A required
              behavior is to convert ^(nil singleSubtree) to singleSubtree
              as the setting of start/stop indexes relies on a single non-nil root
              for non-flat trees.
              </summary>
            
              <remarks>
              Flat trees such as for lists like "idlist : ID+ ;" are left alone
              unless there is only one ID.  For a list, the start/stop indexes
              are set in the nil node.
            
              This method is executed after all rule tree construction and right
              before setTokenBoundaries().
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetUniqueID(System.Object)">
            <summary>For identifying trees.</summary>
            
              <remarks>
              How to identify nodes so we can say "add node to a prior node"?
              Even becomeRoot is an issue.  Use System.identityHashCode(node)
              usually.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.BecomeRoot(Antlr.Runtime.IToken,System.Object)">
            <summary>
              Create a node for newRoot make it the root of oldRoot.
              If oldRoot is a nil root, just copy or move the children to newRoot.
              If not a nil root, make oldRoot a child of newRoot.
              </summary>
            
              <returns>
              Return node created for newRoot.
              </returns>
            
              <remarks>
              Be advised: when debugging ASTs, the DebugTreeAdaptor manually
              calls create(Token child) and then plain becomeRoot(node, node)
              because it needs to trap calls to create, but it can't since it delegates
              to not inherits from the TreeAdaptor.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.Create(System.Int32,Antlr.Runtime.IToken)">
            <summary>
              Create a new node derived from a token, with a new token type.
              This is invoked from an imaginary node ref on right side of a
              rewrite rule as IMAG[$tokenLabel].
              </summary>
            
              <remarks>
              This should invoke createToken(Token).
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.Create(System.Int32,Antlr.Runtime.IToken,System.String)">
            <summary>
              Same as create(tokenType,fromToken) except set the text too.
              This is invoked from an imaginary node ref on right side of a
              rewrite rule as IMAG[$tokenLabel, "IMAG"].
              </summary>
            
              <remarks>
              This should invoke createToken(Token).
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.Create(System.Int32,System.String)">
            <summary>
              Create a new node derived from a token, with a new token type.
              This is invoked from an imaginary node ref on right side of a
              rewrite rule as IMAG["IMAG"].
              </summary>
            
              <remarks>
              This should invoke createToken(int,String).
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetType(System.Object)">
            <summary>For tree parsing, I need to know the token type of a node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.SetType(System.Object,System.Int32)">
            <summary>Node constructors can set the type of a node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.SetText(System.Object,System.String)">
            <summary>Node constructors can set the text of a node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetToken(System.Object)">
            <summary>
            Return the token object from which this node was created.
            Currently used only for printing an error message.
            The error display routine in BaseRecognizer needs to
            display where the input the error occurred. If your
            tree of limitation does not store information that can
            lead you to the token, you can create a token filled with
            the appropriate information and pass that back.  See
            BaseRecognizer.getErrorMessage().
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.SetTokenBoundaries(System.Object,Antlr.Runtime.IToken,Antlr.Runtime.IToken)">
            <summary>
            Where are the bounds in the input token stream for this node and
            all children?  Each rule that creates AST nodes will call this
            method right before returning.  Flat trees (i.e., lists) will
            still usually have a nil root node just to hold the children list.
            That node would contain the start/stop indexes then.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetTokenStartIndex(System.Object)">
            <summary>Get the token start index for this subtree; return -1 if no such index</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetTokenStopIndex(System.Object)">
            <summary>Get the token stop index for this subtree; return -1 if no such index</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetChild(System.Object,System.Int32)">
            <summary>Get a child 0..n-1 node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.SetChild(System.Object,System.Int32,System.Object)">
            <summary>Set ith child (0..n-1) to t; t must be non-null and non-nil node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.DeleteChild(System.Object,System.Int32)">
            <summary>Remove ith child and shift children down from right.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetChildCount(System.Object)">
            <summary>How many children?  If 0, then this is a leaf node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetParent(System.Object)">
            <summary>
            Who is the parent node of this node; if null, implies node is root.
            If your node type doesn't handle this, it's ok but the tree rewrites
            in tree parsers need this functionality.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetChildIndex(System.Object)">
            <summary>
            What index is this node in the child list? Range: 0..n-1
            If your node type doesn't handle this, it's ok but the tree rewrites
            in tree parsers need this functionality.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.ReplaceChildren(System.Object,System.Int32,System.Int32,System.Object)">
            <summary>
              Replace from start to stop child index of parent with t, which might
              be a list.  Number of children may be different after this call.
              </summary>
            
              <remarks>
              If parent is null, don't do anything; must be at root of overall tree.
              Can't replace whatever points to the parent externally.  Do nothing.
              </remarks>
        </member>
        <member name="F:Antlr.Runtime.Tree.BaseTreeAdaptor.treeToUniqueIDMap">
            <summary>
            System.identityHashCode() is not always unique; we have to
            track ourselves.  That's ok, it's only for debugging, though it's
            expensive: we have to create a hashtable with all tree nodes in it.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.ErrorNode(Antlr.Runtime.ITokenStream,Antlr.Runtime.IToken,Antlr.Runtime.IToken,Antlr.Runtime.RecognitionException)">
            <summary>
              Create tree node that holds the start and stop tokens associated
              with an error.
              </summary>
            
              <remarks>
              If you specify your own kind of tree nodes, you will likely have to
              override this method. CommonTree returns Token.INVALID_TOKEN_TYPE
              if no token payload but you might have to set token type for diff
              node type.
            
              You don't have to subclass CommonErrorNode; you will likely need to
              subclass your own tree node class to avoid class cast exception.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.DupTree(System.Object,System.Object)">
            <summary>
            This is generic in the sense that it will work with any kind of
            tree (not just ITree interface).  It invokes the adaptor routines
            not the tree node routines to do the construction.  
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.AddChild(System.Object,System.Object)">
            <summary>
            Add a child to the tree t.  If child is a flat tree (a list), make all
            in list children of t.  Warning: if t has no children, but child does
            and child isNil then you can decide it is ok to move children to t via
            t.children = child.children; i.e., without copying the array.  Just
            make sure that this is consistent with have the user will build
            ASTs.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.BecomeRoot(System.Object,System.Object)">
            <summary>
              If oldRoot is a nil root, just copy or move the children to newRoot.
              If not a nil root, make oldRoot a child of newRoot.
              </summary>
            
              <remarks>
                old=^(nil a b c), new=r yields ^(r a b c)
                old=^(a b c), new=r yields ^(r ^(a b c))
            
              If newRoot is a nil-rooted single child tree, use the single
              child as the new root node.
            
                old=^(nil a b c), new=^(nil r) yields ^(r a b c)
                old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
            
              If oldRoot was null, it's ok, just return newRoot (even if isNil).
            
                old=null, new=r yields r
                old=null, new=^(nil r) yields ^(nil r)
            
              Return newRoot.  Throw an exception if newRoot is not a
              simple node or nil root with a single child node--it must be a root
              node.  If newRoot is ^(nil x) return x as newRoot.
            
              Be advised that it's ok for newRoot to point at oldRoot's
              children; i.e., you don't have to copy the list.  We are
              constructing these nodes so we should have this control for
              efficiency.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.RulePostProcessing(System.Object)">
            <summary>Transform ^(nil x) to x and nil to null</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.CreateToken(System.Int32,System.String)">
            <summary>
              Tell me how to create a token for use with imaginary token nodes.
              For example, there is probably no input symbol associated with imaginary
              token DECL, but you need to create it as a payload or whatever for
              the DECL node as in ^(DECL type ID).
              </summary>
            
              <remarks>
              If you care what the token payload objects' type is, you should
              override this method and any other createToken variant.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.CreateToken(Antlr.Runtime.IToken)">
            <summary>
              Tell me how to create a token for use with imaginary token nodes.
              For example, there is probably no input symbol associated with imaginary
              token DECL, but you need to create it as a payload or whatever for
              the DECL node as in ^(DECL type ID).
              </summary>
            
              <remarks>
              This is a variant of createToken where the new token is derived from
              an actual real input token.  Typically this is for converting '{'
              tokens to BLOCK etc...  You'll see
            
                r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
            
              If you care what the token payload objects' type is, you should
              override this method and any other createToken variant.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTreeAdaptor.DupNode(System.Object)">
            <summary>
              Duplicate a node.  This is part of the factory;
              override if you want another kind of node to be built.
              </summary>
            
              <remarks>
              I could use reflection to prevent having to override this
              but reflection is slow.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTreeAdaptor.CreateToken(System.Int32,System.String)">
            <summary>
              Tell me how to create a token for use with imaginary token nodes.
              For example, there is probably no input symbol associated with imaginary
              token DECL, but you need to create it as a payload or whatever for
              the DECL node as in ^(DECL type ID).
              </summary>
            
              <remarks>
              If you care what the token payload objects' type is, you should
              override this method and any other createToken variant.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTreeAdaptor.CreateToken(Antlr.Runtime.IToken)">
            <summary>
              Tell me how to create a token for use with imaginary token nodes.
              For example, there is probably no input symbol associated with imaginary
              token DECL, but you need to create it as a payload or whatever for
              the DECL node as in ^(DECL type ID).
              </summary>
            
              <remarks>
              This is a variant of createToken where the new token is derived from
              an actual real input token.  Typically this is for converting '{'
              tokens to BLOCK etc...  You'll see
            
                r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
            
              If you care what the token payload objects' type is, you should
              override this method and any other createToken variant.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTreeAdaptor.SetTokenBoundaries(System.Object,Antlr.Runtime.IToken,Antlr.Runtime.IToken)">
            <summary>
            Track start/stop token for subtree root created for a rule.
            Only works with Tree nodes.  For rules that match nothing,
            seems like this will yield start=i and stop=i-1 in a nil node.
            Might be useful info so I'll not force to be i..i.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTreeAdaptor.GetToken(System.Object)">
            <summary>
            What is the Token associated with this node?  If
            you are not using CommonTree, then you must
            override this in your own adaptor.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Parser">
            <summary>
            A parser for TokenStreams.  "parser grammars" result in a subclass
            of this.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.BaseRecognizer">
            <summary>
            A generic recognizer that can handle recognizers generated from
            lexer, parser, and tree grammars.  This is all the parsing
            support code essentially; most of it is error recovery stuff and
            backtracking.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.BaseRecognizer.state">
            <summary>
            State of a lexer, parser, or tree parser are collected into a state
            object so the state can be shared.  This sharing is needed to
            have one grammar import others and share same error variables
            and other state variables.  It's a kind of explicit multiple
            inheritance via delegation of methods and shared state.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.Reset">
            <summary>reset the parser's state; subclasses must rewinds the input stream</summary> 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.Match(Antlr.Runtime.IIntStream,System.Int32,Antlr.Runtime.BitSet)">
            <summary>
              Match current input symbol against ttype.  Attempt
              single token insertion or deletion error recovery.  If
              that fails, throw MismatchedTokenException.
              </summary>
            
              <remarks>
              To turn off single token insertion or deletion error
              recovery, override recoverFromMismatchedToken() and have it
              throw an exception. See TreeParser.recoverFromMismatchedToken().
              This way any error in a rule will cause an exception and
              immediate exit from rule.  Rule would recover by resynchronizing
              to the set of symbols that can follow rule ref.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.MatchAny(Antlr.Runtime.IIntStream)">
            <summary>Match the wildcard: in a symbol</summary> 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.ReportError(Antlr.Runtime.RecognitionException)">
            <summary>Report a recognition problem.</summary>
            
              <remarks>
              This method sets errorRecovery to indicate the parser is recovering
              not parsing.  Once in recovery mode, no errors are generated.
              To get out of recovery mode, the parser must successfully match
              a token (after a resync).  So it will go:
            
             		1. error occurs
             		2. enter recovery mode, report error
             		3. consume until token found in resynch set
             		4. try to resume parsing
             		5. next match() will reset errorRecovery mode
            
              If you override, make sure to update syntaxErrors if you care about that.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetErrorMessage(Antlr.Runtime.RecognitionException,System.String[])">
            <summary>What error message should be generated for the various exception types?</summary>
            
              <remarks>
              Not very object-oriented code, but I like having all error message
              generation within one method rather than spread among all of the
              exception classes. This also makes it much easier for the exception
              handling because the exception classes do not have to have pointers back
              to this object to access utility routines and so on. Also, changing
              the message for an exception type would be difficult because you
              would have to subclassing exception, but then somehow get ANTLR
              to make those kinds of exception objects instead of the default.
              This looks weird, but trust me--it makes the most sense in terms
              of flexibility.
            
              For grammar debugging, you will want to override this to add
              more information such as the stack frame with
              getRuleInvocationStack(e, this.getClass().getName()) and,
              for no viable alts, the decision description and state etc...
            
              Override this to change the message generated for one or more
              exception types.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetErrorHeader(Antlr.Runtime.RecognitionException)">
            <summary>What is the error header, normally line/character position information?</summary> 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetTokenErrorDisplay(Antlr.Runtime.IToken)">
            <summary>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.  Override in that case
            to use t.ToString() (which, for CommonToken, dumps everything about
            the token). This is better than forcing you to override a method in
            your token objects because you don't have to go modify your lexer
            so that it creates a new Java type.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.EmitErrorMessage(System.String)">
            <summary>Override this method to change where error messages go</summary> 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.Recover(Antlr.Runtime.IIntStream,Antlr.Runtime.RecognitionException)">
            <summary>
            Recover from an error found on the input stream.  This is
            for NoViableAlt and mismatched symbol exceptions.  If you enable
            single token insertion and deletion, this will usually not
            handle mismatched symbol exceptions but there could be a mismatched
            token that the match() routine could not recover from.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.BeginResync">
            <summary>
            A hook to listen in on the token consumption during error recovery.
            The DebugParser subclasses this to fire events to the listenter.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.ComputeContextSensitiveRuleFOLLOW">
            <summary>
              Compute the context-sensitive FOLLOW set for current rule.
              This is set of token types that can follow a specific rule
              reference given a specific call chain.  You get the set of
              viable tokens that can possibly come next (lookahead depth 1)
              given the current call chain.  Contrast this with the
              definition of plain FOLLOW for rule r:
              </summary>
            
               FOLLOW(r)={x | S=>*alpha r beta in G and x in FIRST(beta)}
            
              where x in T* and alpha, beta in V*; T is set of terminals and
              V is the set of terminals and nonterminals.  In other words,
              FOLLOW(r) is the set of all tokens that can possibly follow
              references to r in *any* sentential form (context).  At
              runtime, however, we know precisely which context applies as
              we have the call chain.  We may compute the exact (rather
              than covering superset) set of following tokens.
            
              For example, consider grammar:
            
              stat : ID '=' expr ';'      // FOLLOW(stat)=={EOF}
                   | "return" expr '.'
                   ;
              expr : atom ('+' atom)* ;   // FOLLOW(expr)=={';','.',')'}
              atom : INT                  // FOLLOW(atom)=={'+',')',';','.'}
                   | '(' expr ')'
                   ;
            
              The FOLLOW sets are all inclusive whereas context-sensitive
              FOLLOW sets are precisely what could follow a rule reference.
              For input input "i=(3);", here is the derivation:
            
              stat => ID '=' expr ';'
                   => ID '=' atom ('+' atom)* ';'
                   => ID '=' '(' expr ')' ('+' atom)* ';'
                   => ID '=' '(' atom ')' ('+' atom)* ';'
                   => ID '=' '(' INT ')' ('+' atom)* ';'
                   => ID '=' '(' INT ')' ';'
            
              At the "3" token, you'd have a call chain of
            
                stat -> expr -> atom -> expr -> atom
            
              What can follow that specific nested ref to atom?  Exactly ')'
              as you can see by looking at the derivation of this specific
              input.  Contrast this with the FOLLOW(atom)={'+',')',';','.'}.
            
              You want the exact viable token set when recovering from a
              token mismatch.  Upon token mismatch, if LA(1) is member of
              the viable next token set, then you know there is most likely
              a missing token in the input stream.  "Insert" one by just not
              throwing an exception.
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.RecoverFromMismatchedToken(Antlr.Runtime.IIntStream,System.Int32,Antlr.Runtime.BitSet)">
            <summary>Attempt to recover from a single missing or extra token.</summary>
            
              EXTRA TOKEN
            
              LA(1) is not what we are looking for.  If LA(2) has the right token,
              however, then assume LA(1) is some extra spurious token.  Delete it
              and LA(2) as if we were doing a normal match(), which advances the
              input.
            
              MISSING TOKEN
            
              If current token is consistent with what could come after
              ttype then it is ok to "insert" the missing token, else throw
              exception For example, Input "i=(3;" is clearly missing the
              ')'.  When the parser returns from the nested call to expr, it
              will have call chain:
            
                stat -> expr -> atom
            
              and it will be trying to match the ')' at this point in the
              derivation:
            
                   => ID '=' '(' INT ')' ('+' atom)* ';'
                                      ^
              match() will see that ';' doesn't match ')' and report a
              mismatched token error.  To recover, it sees that LA(1)==';'
              is in the set of tokens that can follow the ')' token
              reference in rule atom.  It can assume that you forgot the ')'.
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.RecoverFromMismatchedSet(Antlr.Runtime.IIntStream,Antlr.Runtime.RecognitionException,Antlr.Runtime.BitSet)">
            Not currently used 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetCurrentInputSymbol(Antlr.Runtime.IIntStream)">
            <summary>
              Match needs to return the current input symbol, which gets put
              into the label for the associated token ref; e.g., x=ID.  Token
              and tree parsers need to return different objects. Rather than test
              for input stream type or change the IntStream interface, I use
              a simple method to ask the recognizer to tell me what the current
              input symbol is.
              </summary>
            
              <remarks>This is ignored for lexers.</remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetMissingSymbol(Antlr.Runtime.IIntStream,Antlr.Runtime.RecognitionException,System.Int32,Antlr.Runtime.BitSet)">
            <summary>Conjure up a missing token during error recovery.</summary>
            
              <remarks>
              The recognizer attempts to recover from single missing
              symbols. But, actions might refer to that missing symbol.
              For example, x=ID {f($x);}. The action clearly assumes
              that there has been an identifier matched previously and that
              $x points at that token. If that token is missing, but
              the next token in the stream is what we want we assume that
              this token is missing and we keep going. Because we
              have to return some token to replace the missing token,
              we have to conjure one up. This method gives the user control
              over the tokens returned for missing tokens. Mostly,
              you will want to create something special for identifier
              tokens. For literals such as '{' and ',', the default
              action in the parser or tree parser works. It simply creates
              a CommonToken of the appropriate type. The text will be the token.
              If you change what tokens must be created by the lexer,
              override this method to create the appropriate tokens.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.ConsumeUntil(Antlr.Runtime.IIntStream,Antlr.Runtime.BitSet)">
            <summary>Consume tokens until one matches the given token set</summary> 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.PushFollow(Antlr.Runtime.BitSet)">
            <summary>Push a rule's follow set using our own hardcoded stack</summary> 
        </member>
        <!-- Badly formed XML comment ignored for member "M:Antlr.Runtime.BaseRecognizer.GetRuleInvocationStack" -->
        <member name="M:Antlr.Runtime.BaseRecognizer.GetRuleInvocationStack(System.Diagnostics.StackTrace)">
            <summary>
            A more general version of GetRuleInvocationStack where you can
            pass in the StackTrace of, for example, a RecognitionException
            to get it's rule stack trace.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Antlr.Runtime.BaseRecognizer.ToStrings(System.Collections.Generic.ICollection{Antlr.Runtime.IToken})" -->
        <member name="M:Antlr.Runtime.BaseRecognizer.GetRuleMemoization(System.Int32,System.Int32)">
            <summary>
              Given a rule number and a start token index number, return
              MEMO_RULE_UNKNOWN if the rule has not parsed input starting from
              start index.  If this rule has parsed input starting from the
              start index before, then return where the rule stopped parsing.
              It returns the index of the last token matched by the rule.
              </summary>
            
              <remarks>
              For now we use a hashtable and just the slow Object-based one.
              Later, we can make a special one for ints and also one that
              tosses out data after we commit past input position i.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.AlreadyParsedRule(Antlr.Runtime.IIntStream,System.Int32)">
            <summary>
              Has this rule already parsed input at the current index in the
              input stream?  Return the stop token index or MEMO_RULE_UNKNOWN.
              If we attempted but failed to parse properly before, return
              MEMO_RULE_FAILED.
              </summary>
            
              <remarks>
              This method has a side-effect: if we have seen this input for
              this rule and successfully parsed before, then seek ahead to
              1 past the stop token matched for this rule last time.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.Memoize(Antlr.Runtime.IIntStream,System.Int32,System.Int32)">
            <summary>
            Record whether or not this rule parsed the input at this position
            successfully.  Use a standard java hashtable for now.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetRuleMemoizationCacheSize">
            <summary>return how many rule/input-index pairs there are in total.</summary>
            TODO: this includes synpreds. :(
        </member>
        <member name="P:Antlr.Runtime.BaseRecognizer.NumberOfSyntaxErrors">
            <summary>
              Get number of recognition errors (lexer, parser, tree parser).  Each
              recognizer tracks its own number.  So parser and lexer each have
              separate count.  Does not count the spurious errors found between
              an error and next valid token match
              </summary>
            
              <seealso cref="!:reportError()"/>
        </member>
        <member name="P:Antlr.Runtime.BaseRecognizer.Failed">
            <summary>Return whether or not a backtracking attempt failed.</summary> 
        </member>
        <member name="P:Antlr.Runtime.BaseRecognizer.TokenNames">
            <summary>
            Used to print out token names like ID during debugging and
            error reporting.  The generated parsers implement a method
            that overrides this to point to their String[] tokenNames.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.BaseRecognizer.GrammarFileName">
            <summary>
            For debugging and other purposes, might want the grammar name.
            Have ANTLR generate an implementation for this method.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Parser.TokenStream">
            <summary>Gets or sets the token stream; resets the parser upon a set.</summary> 
        </member>
        <member name="F:Antlr.Runtime.CommonToken.text">
            <summary>
            We need to be able to change the text once in a while.  If
            this is non-null, then getText should return this.  Note that
            start/stop are not affected by changing this.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.CommonToken.index">
            <summary>What token number is this from 0..n-1 tokens; &lt; 0 implies invalid index</summary> 
        </member>
        <member name="F:Antlr.Runtime.CommonToken.start">
            <summary>The char position into the input buffer where this token starts</summary> 
        </member>
        <member name="F:Antlr.Runtime.CommonToken.stop">
            <summary>The char position into the input buffer where this token stops</summary> 
        </member>
        <member name="M:Antlr.Runtime.Debug.Misc.DoubleKeyMap`3.Values(`0)">
            Get all values associated with primary key 
        </member>
        <member name="M:Antlr.Runtime.Debug.Misc.DoubleKeyMap`3.KeySet">
            get all primary keys 
        </member>
        <member name="M:Antlr.Runtime.Debug.Misc.DoubleKeyMap`3.KeySet(`0)">
            get all secondary keys associated with a primary key 
        </member>
        <member name="T:Antlr.Runtime.ANTLRReaderStream">
            <summary>
              Vacuum all input from a Reader and then treat it like a StringStream.
              Manage the buffer manually to avoid unnecessary data copying.
              </summary>
            
              <remarks>
              If you need encoding, use ANTLRInputStream.
              </remarks>
        </member>
        <member name="T:Antlr.Runtime.ANTLRStringStream">
            <summary>
            A pretty quick CharStream that pulls all data from an array
            directly.  Every method call counts in the lexer.  Java's
            strings aren't very good so I'm avoiding.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.data">
            <summary>The data being scanned</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.n">
            <summary>How many characters are actually in the buffer</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.p">
            <summary>0..n-1 index into string of next char</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.line">
            <summary>line number 1..n within the input</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.charPositionInLine">
            <summary>The index of the character relative to the beginning of the line 0..n-1</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.markDepth">
            <summary>tracks how deep mark() calls are nested</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.markers">
            <summary>
            A list of CharStreamState objects that tracks the stream state
            values line, charPositionInLine, and p that can change as you
            move through the input stream.  Indexed from 1..markDepth.
            A null is kept @ index 0.  Create upon first call to mark().
            </summary>
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.lastMarker">
            <summary>Track the last mark() call result value for use in rewind().</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.name">
            <summary>What is name or source of this char stream?</summary> 
        </member>
        <member name="M:Antlr.Runtime.ANTLRStringStream.#ctor(System.String)">
            <summary>Copy data in string to a local char array</summary> 
        </member>
        <member name="M:Antlr.Runtime.ANTLRStringStream.#ctor(System.Char[],System.Int32)">
            <summary>This is the preferred constructor as no data is copied</summary> 
        </member>
        <member name="M:Antlr.Runtime.ANTLRStringStream.Reset">
            <summary>
            Reset the stream so that it's in the same state it was
            when the object was created *except* the data array is not
            touched.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRStringStream.Seek(System.Int32)">
            <summary>
            consume() ahead until p==index; can't just set p=index as we must
            update line and charPositionInLine.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.ANTLRStringStream.Index">
            <summary>
            Return the current input symbol index 0..n where n indicates the
            last symbol has been read.  The index is the index of char to
            be returned from LA(1).
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Debug.DebugEventRepeater">
            <summary>
              A simple event repeater (proxy) that delegates all functionality to the
              listener sent into the ctor.  Useful if you want to listen in on a few
              debug events w/o interrupting the debugger.  Just subclass the repeater
              and override the methods you want to listen in on.  Remember to call
              the method in this class so the event will continue on to the original
              recipient.
              </summary>
            
              <seealso cref="T:Antlr.Runtime.Debug.DebugEventHub"/>
        </member>
        <member name="F:Antlr.Runtime.Debug.DebugTokenStream.lastMarker">
            <summary>Track the last mark() call result value for use in rewind().</summary> 
        </member>
        <member name="M:Antlr.Runtime.Debug.DebugTokenStream.ConsumeInitialHiddenTokens">
            <summary>Consume all initial off-channel tokens</summary> 
        </member>
        <member name="T:Antlr.Runtime.Collections.HashList">
            <summary>
            An Hashtable-backed dictionary that enumerates Keys and Values in 
            insertion order.
            </summary>	
        </member>
        <member name="T:Antlr.Runtime.Tree.CommonErrorNode">
            <summary>A node representing erroneous token range in token stream</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.CommonTree">
            <summary>
            A tree node that is wrapper for a Token object.  After 3.0 release
            while building tree rewrite stuff, it became clear that computing
            parent and child index is very difficult and cumbersome.  Better to
            spend the space in every tree node.  If you don't want these extra
            fields, it's easy to cut them out in your own BaseTree subclass.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.BaseTree">
            <summary>
            A generic tree implementation with no payload.  You must subclass to
            actually have any user data.  ANTLR v3 uses a list of children approach
            instead of the child-sibling approach in v2.  A flat tree (a list) is
            an empty node whose children represent the list.  An empty, but
            non-null node is called "nil".
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.ITree">
            <summary>
              What does a tree look like?  ANTLR has a number of support classes
              such as CommonTreeNodeStream that work on these kinds of trees.  You
              don't have to make your trees implement this interface, but if you do,
              you'll be able to use more support code.
              </summary>
            
              <remarks>
              NOTE: When constructing trees, ANTLR can build any kind of tree; it can
              even use Token objects as trees if you add a child list to your tokens.
            
              This is a tree node without any payload; just navigation and factory stuff.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITree.HasAncestor(System.Int32)">
            <summary>Is there is a node above with token type ttype?</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITree.GetAncestor(System.Int32)">
            <summary>Walk upwards and get first ancestor with this token type.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITree.GetAncestors">
            <summary>
            Return a list of all ancestors of this node.  The first node of
            list is the root and the last is the parent of this node.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITree.FreshenParentAndChildIndexes">
            <summary>Set the parent and child index values for all children</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITree.AddChild(Antlr.Runtime.Tree.ITree)">
            <summary>
            Add t as a child to this node.  If t is null, do nothing.  If t
            is nil, add all children of t to this' children.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITree.SetChild(System.Int32,Antlr.Runtime.Tree.ITree)">
            <summary>Set ith child (0..n-1) to t; t must be non-null and non-nil node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITree.ReplaceChildren(System.Int32,System.Int32,System.Object)">
            <summary>
            Delete children from start to stop and replace with t even if t is
            a list (nil-root tree).  num of children can increase or decrease.
            For huge child lists, inserting children can force walking rest of
            children to set their childindex; could be slow.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITree.ChildIndex">
            <summary>This node is what child index? 0..n-1</summary> 
        </member>
        <member name="P:Antlr.Runtime.Tree.ITree.IsNil">
            <summary>
            Indicates the node is a nil node but may still have children, meaning
            the tree is a flat list.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITree.TokenStartIndex">
            <summary>
            What is the smallest token index (indexing from 0) for this node
            and its children?
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITree.TokenStopIndex">
            <summary>
            What is the largest token index (indexing from 0) for this node
            and its children?
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITree.Type">
            <summary>Return a token type; needed for tree parsing</summary> 
        </member>
        <member name="P:Antlr.Runtime.Tree.ITree.Line">
            <summary>In case we don't have a token payload, what is the line for errors?</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.#ctor(Antlr.Runtime.Tree.ITree)">
            <summary>
            Create a new node from an existing node does nothing for BaseTree
            as there are no fields other than the children list, which cannot
            be copied as the children are not considered part of this node. 
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.AddChild(Antlr.Runtime.Tree.ITree)">
            <summary>Add t as child of this node.</summary>
            
              <remarks>
              Warning: if t has no children, but child does
              and child isNil then this routine moves children to t via
              t.children = child.children; i.e., without copying the array.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.AddChildren(System.Collections.Generic.IEnumerable{Antlr.Runtime.Tree.ITree})">
            <summary>Add all elements of kids list as children of this node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.ReplaceChildren(System.Int32,System.Int32,System.Object)">
            <summary>
            Delete children from start to stop and replace with t even if t is
            a list (nil-root tree).  num of children can increase or decrease.
            For huge child lists, inserting children can force walking rest of
            children to set their childindex; could be slow.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.CreateChildrenList">
            <summary>Override in a subclass to change the impl of children list</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.FreshenParentAndChildIndexes">
            <summary>Set the parent and child index values for all child of t</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.HasAncestor(System.Int32)">
            <summary>Walk upwards looking for ancestor with this token type.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.GetAncestor(System.Int32)">
            <summary>Walk upwards and get first ancestor with this token type.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.GetAncestors">
            <summary>
            Return a list of all ancestors of this node.  The first node of
            list is the root and the last is the parent of this node.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.ToStringTree">
            <summary>Print out a whole tree not just a node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.ToString">
            <summary>Override to say how a node (not a tree) should look as text</summary> 
        </member>
        <member name="P:Antlr.Runtime.Tree.BaseTree.Children">
            <summary>
            Get the children internal List; note that if you directly mess with
            the list, do so at your own risk.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.BaseTree.Parent">
            <summary>BaseTree doesn't track parent pointers.</summary> 
        </member>
        <member name="P:Antlr.Runtime.Tree.BaseTree.ChildIndex">
            <summary>BaseTree doesn't track child indexes.</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTree.token">
            <summary>A single token is the payload</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTree.startIndex">
            <summary>
            What token indexes bracket all tokens associated with this node
            and below?
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTree.parent">
            <summary>Who is the parent node of this node; if null, implies node is root</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTree.childIndex">
            <summary>What index is this node in the child list? Range: 0..n-1</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTree.SetUnknownTokenBoundaries">
            <summary>
            For every node in this subtree, make sure it's start/stop token's
            are set.  Walk depth first, visit bottom up.  Only updates nodes
            with at least one token index &lt; 0.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.BufferedTreeNodeStream">
            <summary>A buffered stream of tree nodes.  Nodes can be from a tree of ANY kind.</summary>
            
              This node stream sucks all nodes out of the tree specified in
              the constructor during construction and makes pointers into
              the tree using an array of Object pointers. The stream necessarily
              includes pointers to DOWN and UP and EOF nodes.
            
              This stream knows how to mark/release for backtracking.
            
              This stream is most suitable for tree interpreters that need to
              jump around a lot or for tree parsers requiring speed (at cost of memory).
              There is some duplicated functionality here with UnBufferedTreeNodeStream
              but just in bookkeeping, not tree walking etc...
            
              TARGET DEVELOPERS:
            
              This is the old CommonTreeNodeStream that buffered up entire node stream.
              No need to implement really as new CommonTreeNodeStream is much better
              and covers what we need.
            
              @see CommonTreeNodeStream
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.nodes">
            <summary>The complete mapping from stream index to tree node.
              This buffer includes pointers to DOWN, UP, and EOF nodes.
              It is built upon ctor invocation.  The elements are type
              Object as we don't what the trees look like.</summary>
            
              Load upon first need of the buffer so we can set token types
              of interest for reverseIndexing.  Slows us down a wee bit to
              do all of the if p==-1 testing everywhere though.
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.root">
            <summary>Pull nodes from which tree?</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.tokens">
            <summary>IF this tree (root) was created from a token stream, track it.</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.adaptor">
            <summary>What tree adaptor was used to build these trees</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.uniqueNavigationNodes">
            <summary>Reuse same DOWN, UP navigation nodes unless this is true</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.p">
            <summary>The index into the nodes list of the current node (next node
            to consume).  If -1, nodes array not filled yet.</summary>
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.lastMarker">
            <summary>Track the last mark() call result value for use in rewind().</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.calls">
            <summary>Stack of indexes used for push/pop calls</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.FillBuffer">
            Walk tree with depth-first-search and fill nodes buffer.
            Don't do DOWN, UP nodes if its a list (t is isNil).
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.GetNodeIndex(System.Object)">
            What is the stream index for node? 0..n-1
            Return -1 if node not found.
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.AddNavigationNode(System.Int32)">
            As we flatten the tree, we use UP, DOWN nodes to represent
            the tree structure.  When debugging we need unique nodes
            so instantiate new ones when uniqueNavigationNodes is true.
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.LB(System.Int32)">
            <summary>Look backwards k nodes</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.Push(System.Int32)">
            <summary>
            Make stream jump to a new location, saving old location.
            Switch back with pop().
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.Pop">
            <summary>
            Seek back to previous index saved during last push() call.
            Return top of stack (return index).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.ToTokenTypeString">
            <summary>Used for testing, just return the token type stream</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.ToTokenString(System.Int32,System.Int32)">
            <summary>Debugging</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeVisitor">
            <summary>Do a depth first walk of a tree, applying pre() and post() actions as we go.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeVisitor.Visit(System.Object,Antlr.Runtime.Tree.ITreeVisitorAction)">
            <summary>
            Visit every node in tree t and trigger an action for each node
            before/after having visited all of its children.  Bottom up walk.
            Execute both actions even if t has no children.  Ignore return
            results from transforming children since they will have altered
            the child list of this node (their parent).  Return result of
            applying post action to this node.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.TokenRewriteStream">
            Useful for dumping out the input stream after doing some
              augmentation or other manipulations.
            
              You can insert stuff, replace, and delete chunks.  Note that the
              operations are done lazily--only if you convert the buffer to a
              String.  This is very efficient because you are not moving data around
              all the time.  As the buffer of tokens is converted to strings, the
              toString() method(s) check to see if there is an operation at the
              current index.  If so, the operation is done and then normal String
              rendering continues on the buffer.  This is like having multiple Turing
              machine instruction streams (programs) operating on a single input tape. :)
            
              Since the operations are done lazily at toString-time, operations do not
              screw up the token index values.  That is, an insert operation at token
              index i does not change the index values for tokens i+1..n-1.
            
              Because operations never actually alter the buffer, you may always get
              the original token stream back without undoing anything.  Since
              the instructions are queued up, you can easily simulate transactions and
              roll back any changes if there is an error just by removing instructions.
              For example,
            
               CharStream input = new ANTLRFileStream("input");
               TLexer lex = new TLexer(input);
               TokenRewriteStream tokens = new TokenRewriteStream(lex);
               T parser = new T(tokens);
               parser.startRule();
            
             	 Then in the rules, you can execute
                  Token t,u;
                  ...
                  input.insertAfter(t, "text to put after t");}
             		input.insertAfter(u, "text after u");}
             		System.out.println(tokens.toString());
            
              Actually, you have to cast the 'input' to a TokenRewriteStream. :(
            
              You can also have multiple "instruction streams" and get multiple
              rewrites from a single pass over the input.  Just name the instruction
              streams and use that name again when printing the buffer.  This could be
              useful for generating a C file and also its header file--all from the
              same buffer:
            
                  tokens.insertAfter("pass1", t, "text to put after t");}
             		tokens.insertAfter("pass2", u, "text after u");}
             		System.out.println(tokens.toString("pass1"));
             		System.out.println(tokens.toString("pass2"));
            
              If you don't use named rewrite streams, a "default" stream is used as
              the first example shows.
        </member>
        <member name="T:Antlr.Runtime.CommonTokenStream">
            <summary>
              The most common stream of tokens is one where every token is buffered up
              and tokens are prefiltered for a certain channel (the parser will only
              see these tokens and cannot change the filter channel number during the
              parse).
              </summary>
            
              <remarks>TODO: how to access the full token stream?  How to track all tokens matched per rule?</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Antlr.Runtime.BufferedTokenStream" -->
        <member name="F:Antlr.Runtime.BufferedTokenStream._tokens">
            Record every single token pulled from the source so we can reproduce
            chunks of it later.  The buffer in LookaheadStream overlaps sometimes
            as its moving window moves through the input.  This list captures
            everything so we can access complete input text.
        </member>
        <member name="F:Antlr.Runtime.BufferedTokenStream._lastMarker">
            Track the last mark() call result value for use in rewind(). 
        </member>
        <member name="F:Antlr.Runtime.BufferedTokenStream._p">
            The index into the tokens list of the current token (next token
            to consume).  tokens[p] should be LT(1).  p=-1 indicates need
            to initialize with first token.  The ctor doesn't get a token.
            First call to LT(1) or whatever gets the first token and sets p=0;
        </member>
        <member name="M:Antlr.Runtime.BufferedTokenStream.Consume">
            Move the input pointer to the next incoming token.  The stream
              must become active with LT(1) available.  consume() simply
              moves the input pointer so that LT(1) points at the next
              input symbol. Consume at least one token.
            
              Walk past any token not on the channel the parser is listening to.
        </member>
        <member name="M:Antlr.Runtime.BufferedTokenStream.Sync(System.Int32)">
            Make sure index i in tokens has a token. 
        </member>
        <member name="M:Antlr.Runtime.BufferedTokenStream.Fetch(System.Int32)">
            add n elements to buffer 
        </member>
        <member name="M:Antlr.Runtime.BufferedTokenStream.GetTokens(System.Int32,System.Int32,Antlr.Runtime.BitSet)">
            Given a start and stop index, return a List of all tokens in
            the token type BitSet.  Return null if no tokens were found.  This
            method looks at both on and off channel tokens.
        </member>
        <member name="P:Antlr.Runtime.BufferedTokenStream.Range">
            <summary>
            How deep have we gone?
            </summary>
        </member>
        <member name="F:Antlr.Runtime.CommonTokenStream._channel">
            Skip tokens on any channel but this one; this is how we skip whitespace... 
        </member>
        <member name="M:Antlr.Runtime.CommonTokenStream.Consume">
            Always leave p on an on-channel token. 
        </member>
        <member name="M:Antlr.Runtime.CommonTokenStream.SkipOffTokenChannels(System.Int32)">
            Given a starting index, return the index of the first on-channel
            token.
        </member>
        <member name="P:Antlr.Runtime.CommonTokenStream.TokenSource">
            Reset this token stream by setting its token source. 
        </member>
        <member name="F:Antlr.Runtime.TokenRewriteStream.programs">
            <summary>
            You may have multiple, named streams of rewrite operations.
            I'm calling these things "programs."
            Maps String (name) -> rewrite (List)
            </summary>
        </member>
        <member name="F:Antlr.Runtime.TokenRewriteStream.lastRewriteTokenIndexes">
            <summary>Map String (program name) -> Integer index</summary> 
        </member>
        <member name="M:Antlr.Runtime.TokenRewriteStream.Rollback(System.String,System.Int32)">
            <summary>
            Rollback the instruction stream for a program so that
            the indicated instruction (via instructionIndex) is no
            longer in the stream.  UNTESTED!
            </summary>
        </member>
        <member name="M:Antlr.Runtime.TokenRewriteStream.DeleteProgram(System.String)">
            <summary>Reset the program so that no instructions exist</summary> 
        </member>
        <member name="M:Antlr.Runtime.TokenRewriteStream.ReduceToSingleOperationPerIndex(System.Collections.Generic.IList{Antlr.Runtime.TokenRewriteStream.RewriteOperation})">
            We need to combine operations and report invalid operations (like
              overlapping replaces that are not completed nested).  Inserts to
              same index need to be combined etc...   Here are the cases:
            
              I.i.u I.j.v								leave alone, nonoverlapping
              I.i.u I.i.v								combine: Iivu
            
              R.i-j.u R.x-y.v	| i-j in x-y			delete first R
              R.i-j.u R.i-j.v							delete first R
              R.i-j.u R.x-y.v	| x-y in i-j			ERROR
              R.i-j.u R.x-y.v	| boundaries overlap	ERROR
            
              I.i.u R.x-y.v | i in x-y				delete I
              I.i.u R.x-y.v | i not in x-y			leave alone, nonoverlapping
              R.x-y.v I.i.u | i in x-y				ERROR
              R.x-y.v I.x.u 							R.x-y.uv (combine, delete I)
              R.x-y.v I.i.u | i not in x-y			leave alone, nonoverlapping
            
              I.i.u = insert u before op @ index i
              R.x-y.u = replace x-y indexed tokens with u
            
              First we need to examine replaces.  For any replace op:
            
             		1. wipe out any insertions before op within that range.
            		2. Drop any replace op before that is contained completely within
                     that range.
            		3. Throw exception upon boundary overlap with any previous replace.
            
              Then we can deal with inserts:
            
             		1. for any inserts to same index, combine even if not adjacent.
             		2. for any prior replace with same left boundary, combine this
                     insert with replace and delete this replace.
             		3. throw exception if index in same range as previous replace
            
              Don't actually delete; make op null in list. Easier to walk list.
              Later we can throw as we add to index -> op map.
            
              Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
              inserted stuff would be before the replace range.  But, if you
              add tokens in front of a method body '{' and then delete the method
              body, I think the stuff before the '{' you added should disappear too.
            
              Return a map from token index to operation.
        </member>
        <member name="M:Antlr.Runtime.TokenRewriteStream.GetKindOfOps(System.Collections.Generic.IList{Antlr.Runtime.TokenRewriteStream.RewriteOperation},System.Type,System.Int32)">
            <summary>Get all operations before an index of a particular kind</summary> 
        </member>
        <member name="F:Antlr.Runtime.TokenRewriteStream.RewriteOperation.instructionIndex">
            <summary>What index into rewrites List are we?</summary> 
        </member>
        <member name="F:Antlr.Runtime.TokenRewriteStream.RewriteOperation.index">
            <summary>Token buffer index.</summary> 
        </member>
        <member name="M:Antlr.Runtime.TokenRewriteStream.RewriteOperation.Execute(System.Text.StringBuilder)">
            <summary>
            Execute the rewrite operation by possibly adding to the buffer.
            Return the index of the next token to operate on.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.TokenRewriteStream.ReplaceOp">
            <summary>
            I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
            instructions.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.RewriteCardinalityException">
            <summary>
            Base class for all exceptions thrown during AST rewrite construction.
            This signifies a case where the cardinality of two or more elements
            in a subrule are different: (ID INT)+ where |ID|!=|INT|
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Debug.Tracer">
            <summary>
            The default tracer mimics the traceParser behavior of ANTLR 2.x.
            This listens for debugging events from the parser and implies
            that you cannot debug and trace at the same time.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.ITokenSource">
            <summary>
            A source of tokens must provide a sequence of tokens via NextToken()
            and also must reveal it's source of characters; CommonToken's text is
            computed from a CharStream; it only store indices into the char stream.
            
            Errors from the lexer are never passed to the parser.  Either you want
            to keep going or you do not upon token recognition error.  If you do not
            want to continue lexing then you do not want to continue parsing.  Just
            throw an exception not under RecognitionException and Java will naturally
            toss you all the way out of the recognizers.  If you want to continue
            lexing then you should not throw an exception to the parser--it has already
            requested a token.  Keep lexing until you get a valid one.  Just report
            errors and keep going, looking for a valid token.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ITokenSource.NextToken">
            <summary>
            Returns a Token object from the input stream (usually a CharStream).
            Does not fail/return upon lexing error; just keeps chewing on the 
            characters until it gets a good one; errors are not passed through 
            to the parser.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.ITokenSource.SourceName">
            <summary>
            Where are you getting tokens from? normally the implication will simply
            ask lexers input stream.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.ClassicToken">
            <summary>
            A Token object like we'd use in ANTLR 2.x; has an actual string created
            and associated with this object.  These objects are needed for imaginary
            tree nodes that have payload objects.  We need to create a Token object
            that has a string; the tree node will point at this token.  CommonToken
            has indexes into a char stream and hence cannot be used to introduce
            new strings.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.ClassicToken.index">
            <summary>What token number is this from 0..n-1 tokens</summary> 
        </member>
        <member name="T:Antlr.Runtime.LegacyCommonTokenStream">
            <summary>
              The most common stream of tokens is one where every token is buffered up
              and tokens are prefiltered for a certain channel (the parser will only
              see these tokens and cannot change the filter channel number during the
              parse).
              </summary>
            
              <remarks>TODO: how to access the full token stream?  How to track all tokens matched per rule?</remarks>
        </member>
        <member name="F:Antlr.Runtime.LegacyCommonTokenStream.tokens">
            <summary>
            Record every single token pulled from the source so we can reproduce
            chunks of it later.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Antlr.Runtime.LegacyCommonTokenStream.channelOverrideMap" -->
        <!-- Badly formed XML comment ignored for member "F:Antlr.Runtime.LegacyCommonTokenStream.discardSet" -->
        <member name="F:Antlr.Runtime.LegacyCommonTokenStream.channel">
            <summary>Skip tokens on any channel but this one; this is how we skip whitespace...</summary> 
        </member>
        <member name="F:Antlr.Runtime.LegacyCommonTokenStream.discardOffChannelTokens">
            <summary>By default, track all incoming tokens</summary> 
        </member>
        <member name="F:Antlr.Runtime.LegacyCommonTokenStream.lastMarker">
            <summary>Track the last mark() call result value for use in rewind().</summary> 
        </member>
        <member name="F:Antlr.Runtime.LegacyCommonTokenStream.p">
            <summary>
            The index into the tokens list of the current token (next token
            to consume).  p==-1 indicates that the tokens list is empty
            </summary>
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.SetTokenSource(Antlr.Runtime.ITokenSource)">
            <summary>Reset this token stream by setting its token source.</summary> 
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.FillBuffer">
            <summary>
            Load all tokens from the token source and put in tokens.
            This is done upon first LT request because you might want to
            set some token type / channel overrides before filling buffer.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.Consume">
            <summary>
              Move the input pointer to the next incoming token.  The stream
              must become active with LT(1) available.  consume() simply
              moves the input pointer so that LT(1) points at the next
              input symbol. Consume at least one token.
              </summary>
            
              <remarks>
              Walk past any token not on the channel the parser is listening to.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.SkipOffTokenChannels(System.Int32)">
            <summary>Given a starting index, return the index of the first on-channel token.</summary> 
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.SetTokenTypeChannel(System.Int32,System.Int32)">
            <summary>
            A simple filter mechanism whereby you can tell this token stream
            to force all tokens of type ttype to be on channel.  For example,
            when interpreting, we cannot exec actions so we need to tell
            the stream to force all WS and NEWLINE to be a different, ignored
            channel.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.GetTokens(System.Int32,System.Int32,Antlr.Runtime.BitSet)">
            <summary>
            Given a start and stop index, return a List of all tokens in
            the token type BitSet.  Return null if no tokens were found.  This
            method looks at both on and off channel tokens.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.LT(System.Int32)">
            <summary>
            Get the ith token from the current position 1..n where k=1 is the
            first symbol of lookahead.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.LB(System.Int32)">
            <summary>Look backwards k tokens on-channel tokens</summary> 
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.Get(System.Int32)">
            <summary>
            Return absolute token i; ignore which channel the tokens are on;
            that is, count all tokens not just on-channel tokens.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.LegacyCommonTokenStream.Range">
            <summary>
            How deep have we gone?
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeIterator">
            Return a node stream from a doubly-linked tree whose nodes
              know what child index they are.  No remove() is supported.
            
              Emit navigation nodes (DOWN, UP, and EOF) to let show tree structure.
        </member>
        <member name="F:Antlr.Runtime.Tree.TreeIterator.nodes">
            If we emit UP/DOWN nodes, we need to spit out multiple nodes per
            next() call.
        </member>
        <member name="T:Antlr.Runtime.Tree.RewriteEmptyStreamException">
            <summary>Ref to ID or expr but no tokens in ID stream or subtrees in expr stream</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeWizard">
            <summary>
              Build and navigate trees with this object.  Must know about the names
              of tokens so you have to pass in a map or array of token names (from which
              this class can build the map).  I.e., Token DECL means nothing unless the
              class can translate it to a token type.
              </summary>
            
              <remarks>
              In order to create nodes and navigate, this class needs a TreeAdaptor.
            
              This class can build a token type -> node index for repeated use or for
              iterating over the various nodes with a particular type.
            
              This class works in conjunction with the TreeAdaptor rather than moving
              all this functionality into the adaptor.  An adaptor helps build and
              navigate trees using methods.  This class helps you do it with string
              patterns like "(A B C)".  You can create a tree from that pattern or
              match subtrees against it.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.ComputeTokenTypes(System.String[])">
            <summary>
            Compute a Map&lt;String, Integer&gt; that is an inverted index of
            tokenNames (which maps int token types to names).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.GetTokenType(System.String)">
            <summary>Using the map of token names to token types, return the type.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Index(System.Object)">
            <summary>
              Walk the entire tree and make a node name to nodes mapping.
              For now, use recursion but later nonrecursive version may be
              more efficient.  Returns Map&lt;Integer, List&gt; where the List is
              of your AST node type.  The Integer is the token type of the node.
              </summary>
            
              <remarks>
              TODO: save this index so that find and visit are faster
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.IndexCore(System.Object,System.Collections.Generic.IDictionary{System.Int32,System.Collections.IList})">
            <summary>Do the work for index</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Find(System.Object,System.Int32)">
            <summary>Return a List of tree nodes with token type ttype</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Find(System.Object,System.String)">
            <summary>Return a List of subtrees matching pattern.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Visit(System.Object,System.Int32,Antlr.Runtime.Tree.TreeWizard.IContextVisitor)">
            <summary>
            Visit every ttype node in t, invoking the visitor.  This is a quicker
            version of the general visit(t, pattern) method.  The labels arg
            of the visitor action method is never set (it's null) since using
            a token type rather than a pattern doesn't let us set a label.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.VisitCore(System.Object,System.Object,System.Int32,System.Int32,Antlr.Runtime.Tree.TreeWizard.IContextVisitor)">
            <summary>Do the recursive work for visit</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Visit(System.Object,System.String,Antlr.Runtime.Tree.TreeWizard.IContextVisitor)">
            <summary>
            For all subtrees that match the pattern, execute the visit action.
            The implementation uses the root node of the pattern in combination
            with visit(t, ttype, visitor) so nil-rooted patterns are not allowed.
            Patterns with wildcard roots are also not allowed.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Parse(System.Object,System.String,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
              Given a pattern like (ASSIGN %lhs:ID %rhs:.) with optional labels
              on the various nodes and '.' (dot) as the node/subtree wildcard,
              return true if the pattern matches and fill the labels Map with
              the labels pointing at the appropriate nodes.  Return false if
              the pattern is malformed or the tree does not match.
              </summary>
            
              <remarks>
              If a node specifies a text arg in pattern, then that must match
              for that node in t.
            
              TODO: what's a better way to indicate bad pattern? Exceptions are a hassle 
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.ParseCore(System.Object,Antlr.Runtime.Tree.TreeWizard.TreePattern,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Do the work for parse. Check to see if the t2 pattern fits the
            structure and token types in t1.  Check text if the pattern has
            text arguments on nodes.  Fill labels map with pointers to nodes
            in tree matched against nodes in pattern with labels.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Create(System.String)">
            <summary>
              Create a tree or node from the indicated tree pattern that closely
              follows ANTLR tree grammar tree element syntax:
            
                  (root child1 ... child2).
              </summary>
            
              <remarks>
              You can also just pass in a node: ID
             
              Any node can have a text argument: ID[foo]
              (notice there are no quotes around foo--it's clear it's a string).
            
              nil is a special name meaning "give me a nil node".  Useful for
              making lists: (nil A B C) is a list of A B C.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Equals(System.Object,System.Object,Antlr.Runtime.Tree.ITreeAdaptor)">
            <summary>
              Compare t1 and t2; return true if token types/text, structure match exactly.
              The trees are examined in their entirety so that (A B) does not match
              (A B C) nor (A (B C)). 
              </summary>
            
              <remarks>
              TODO: allow them to pass in a comparator
              TODO: have a version that is nonstatic so it can use instance adaptor
            
              I cannot rely on the tree node's equals() implementation as I make
              no constraints at all on the node types nor interface etc... 
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Equals(System.Object,System.Object)">
            <summary>
            Compare type, structure, and text of two trees, assuming adaptor in
            this instance of a TreeWizard.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeWizard.TreePattern">
            <summary>
            When using %label:TOKENNAME in a tree for parse(), we must
            track the label.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeWizard.TreePatternTreeAdaptor">
            <summary>This adaptor creates TreePattern objects for use during scan()</summary> 
        </member>
        <member name="T:Antlr.Runtime.Constants">
            <summary>
            Global constants
            </summary>
        </member>
        <member name="T:Antlr.Runtime.IRuleReturnScope`1">
            <summary>
            Rules can have start/stop info.
            </summary>
            <typeparam name="TLabel">The element type of the input stream.</typeparam>
        </member>
        <member name="P:Antlr.Runtime.IRuleReturnScope`1.Start">
            <summary>
            Gets the start element from the input stream
            </summary>
        </member>
        <member name="P:Antlr.Runtime.IRuleReturnScope`1.Stop">
            <summary>
            Gets the stop element from the input stream
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeRuleReturnScope`1">
            <summary>
            This is identical to the ParserRuleReturnScope except that
            the start property is a tree nodes not Token object
            when you are parsing trees.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.TreeRuleReturnScope`1.Start">
            <summary>Gets the first node or root node of tree matched for this rule.</summary> 
        </member>
        <member name="T:Antlr.Runtime.DFA">
            <summary>A DFA implemented as a set of transition tables.</summary>
            
              <remarks>
              Any state that has a semantic predicate edge is special; those states
              are generated with if-then-else structures in a specialStateTransition()
              which is generated by cyclicDFA template.
            
              There are at most 32767 states (16-bit signed short).
              Could get away with byte sometimes but would have to generate different
              types and the simulation code too.  For a point of reference, the Java
              lexer's Tokens rule DFA has 326 states roughly.
              </remarks>
        </member>
        <member name="F:Antlr.Runtime.DFA.recognizer">
            <summary>Which recognizer encloses this DFA?  Needed to check backtracking</summary> 
        </member>
        <member name="M:Antlr.Runtime.DFA.Predict(Antlr.Runtime.IIntStream)">
            <summary>
            From the input stream, predict what alternative will succeed
            using this DFA (representing the covering regular approximation
            to the underlying CFL).  Return an alternative number 1..n.  Throw
            an exception upon error.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.DFA.Error(Antlr.Runtime.NoViableAltException)">
            <summary>A hook for debugging interface</summary> 
        </member>
        <member name="M:Antlr.Runtime.DFA.UnpackEncodedString(System.String)">
            <summary>
            Given a String that has a run-length-encoding of some unsigned shorts
            like "\1\2\3\9", convert to short[] {2,9,9,9}.  We do this to avoid
            static short[] which generates so much init code that the class won't
            compile. :(
            </summary>
        </member>
        <member name="M:Antlr.Runtime.DFA.UnpackEncodedStringToUnsignedChars(System.String)">
            <summary>Hideous duplication of code, but I need different typed arrays out :(</summary> 
        </member>
        <member name="T:Antlr.Runtime.ANTLRFileStream">
            <summary>
            A character stream - an <see cref="T:Antlr.Runtime.ICharStream"/> - that loads 
            and caches the contents of it's underlying file fully during 
            object construction
            </summary>
            <remarks>
            This looks very much like an ANTLReaderStream or an ANTLRInputStream 
            but, it is a special case. Since we know the exact size of the file to 
            load, we can avoid lots of data copying and buffer resizing.
            </remarks>
        </member>
        <member name="M:Antlr.Runtime.ANTLRFileStream.#ctor">
            <summary>
            Initializes a new instance of the ANTLRFileStream class
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRFileStream.#ctor(System.String)">
            <summary>
            Initializes a new instance of the ANTLRFileStream class for the
            specified file name
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRFileStream.#ctor(System.String,System.Text.Encoding)">
            <summary>
            Initializes a new instance of the ANTLRFileStream class for the
            specified file name and encoding
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRFileStream.Load(System.String,System.Text.Encoding)">
            <summary>
            Loads and buffers the specified file to be used as this 
            ANTLRFileStream's source
            </summary>
            <param name="fileName">File to load</param>
            <param name="encoding">Encoding to apply to file</param>
        </member>
        <member name="F:Antlr.Runtime.ANTLRFileStream.fileName">
            <summary>Fully qualified name of the stream's underlying file</summary>
        </member>
        <member name="P:Antlr.Runtime.ANTLRFileStream.SourceName">
            <summary>
            Gets the file name of this ANTLRFileStream underlying file
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Tree.TreePatternLexer.pattern">
            <summary>The tree pattern to lex like "(A B C)"</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.TreePatternLexer.p">
            <summary>Index into input string</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.TreePatternLexer.c">
            <summary>Current char</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.TreePatternLexer.n">
            <summary>How long is the pattern in char?</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.TreePatternLexer.sval">
            <summary>Set when token type is ID or ARG (name mimics Java's StreamTokenizer)</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream._root">
            <summary>Pull nodes from which tree?</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream.tokens">
            <summary>If this tree (root) was created from a token stream, track it.</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream._adaptor">
            <summary>What tree adaptor was used to build these trees</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream._it">
            The tree iterator we are using 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream._calls">
            <summary>Stack of indexes used for push/pop calls</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream._hasNilRoot">
            <summary>Tree (nil A B C) trees like flat A B C streams</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream._level">
            <summary>Tracks tree depth.  Level=0 means we're at root node level.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTreeNodeStream.Push(System.Int32)">
            Make stream jump to a new location, saving old location.
            Switch back with pop().
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTreeNodeStream.Pop">
            Seek back to previous index saved during last push() call.
            Return top of stack (return index).
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTreeNodeStream.ToTokenTypeString">
            <summary>For debugging; destructive: moves tree iterator to end.</summary> 
        </member>
        <member name="T:Antlr.Runtime.CharStreamState">
            <summary>
            This is the complete state of a stream.
            
            When walking ahead with cyclic DFA for syntactic predicates, we 
            need to record the state of the input stream (char index, line, 
            etc...) so that we can rewind the state after scanning ahead.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.CharStreamState.p">
            <summary>Index into the char stream of next lookahead char </summary>
        </member>
        <member name="F:Antlr.Runtime.CharStreamState.line">
            <summary>What line number is the scanner at before processing buffer[p]? </summary>
        </member>
        <member name="F:Antlr.Runtime.CharStreamState.charPositionInLine">
            <summary>What char position 0..n-1 in line is scanner before processing buffer[p]? </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.RewriteRuleNodeStream">
            <summary>
            Queues up nodes matched on left side of -> in a tree parser. This is
            the analog of RewriteRuleTokenStream for normal parsers. 
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleNodeStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Object)">
            <summary>Create a stream with one element</summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleNodeStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Collections.Generic.IList{System.Object})">
            <summary>Create a stream, but feed off an existing list</summary>
        </member>
        <member name="T:Antlr.Runtime.Misc.Stats">
            <summary>Stats routines needed by profiler etc...</summary>
            
              <remarks>
              note that these routines return 0.0 if no values exist in the X[]
              which is not "correct", but it is useful so I don't generate NaN
              in my output
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Misc.Stats.Stddev(System.Int32[])">
            <summary>Compute the sample (unbiased estimator) standard deviation following:</summary>
            
              <remarks>
              Computing Deviations: Standard Accuracy
              Tony F. Chan and John Gregg Lewis
              Stanford University
              Communications of ACM September 1979 of Volume 22 the ACM Number 9
            
              The "two-pass" method from the paper; supposed to have better
              numerical properties than the textbook summation/sqrt.  To me
              this looks like the textbook method, but I ain't no numerical
              methods guy.
              </remarks>
        </member>
        <member name="T:Antlr.Runtime.Debug.ParseTreeBuilder">
            <summary>
            This parser listener tracks rule entry/exit and token matches
            to build a simple parse tree using ParseTree nodes.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.ParseTreeBuilder.Create(System.Object)">
            <summary>
            What kind of node to create.  You might want to override
            so I factored out creation here.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.ParseTreeBuilder.EnterDecision(System.Int32,System.Boolean)">
            <summary>Backtracking or cyclic DFA, don't want to add nodes to tree</summary> 
        </member>
        <member name="T:Antlr.Runtime.Debug.DebugTreeAdaptor">
            <summary>
              A TreeAdaptor proxy that fires debugging events to a DebugEventListener
              delegate and uses the TreeAdaptor delegate to do the actual work.  All
              AST events are triggered by this adaptor; no code gen changes are needed
              in generated rules.  Debugging events are triggered *after* invoking
              tree adaptor routines.
              </summary>
            
              <remarks>
              Trees created with actions in rewrite actions like "-&gt; ^(ADD {foo} {bar})"
              cannot be tracked as they might not use the adaptor to create foo, bar.
              The debug listener has to deal with tree node IDs for which it did
              not see a createNode event.  A single &lt;unknown&gt; node is sufficient even
              if it represents a whole tree.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Debug.DebugTreeAdaptor.SimulateTreeConstruction(System.Object)">
            <summary>^(A B C): emit create A, create B, add child, ...</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeFilter">
                 Cut-n-paste from material I'm not using in the book anymore (edit later
                 to make sense):
            
                 Now, how are we going to test these tree patterns against every
                subtree in our original tree?  In what order should we visit nodes?
                For this application, it turns out we need a simple ``apply once''
                rule application strategy and a ``down then up'' tree traversal
                strategy.  Let's look at rule application first.
            
                As we visit each node, we need to see if any of our patterns match. If
                a pattern matches, we execute the associated tree rewrite and move on
                to the next node. In other words, we only look for a single rule
                application opportunity (we'll see below that we sometimes need to
                repeatedly apply rules). The following method applies a rule in a @cl
                TreeParser (derived from a tree grammar) to a tree:
            
                here is where weReferenced code/walking/patterns/TreePatternMatcher.java
            
                It uses reflection to lookup the appropriate rule within the generated
                tree parser class (@cl Simplify in this case). Most of the time, the
                rule will not match the tree.  To avoid issuing syntax errors and
                attempting error recovery, it bumps up the backtracking level.  Upon
                failure, the invoked rule immediately returns. If you don't plan on
                using this technique in your own ANTLR-based application, don't sweat
                the details. This method boils down to ``call a rule to match a tree,
                executing any embedded actions and rewrite rules.''
            
                At this point, we know how to define tree grammar rules and how to
                apply them to a particular subtree. The final piece of the tree
                pattern matcher is the actual tree traversal. We have to get the
                correct node visitation order.  In particular, we need to perform the
                scalar-vector multiply transformation on the way down (preorder) and
                we need to reduce multiply-by-zero subtrees on the way up (postorder).
            
                To implement a top-down visitor, we do a depth first walk of the tree,
                executing an action in the preorder position. To get a bottom-up
                visitor, we execute an action in the postorder position.  ANTLR
                provides a standard @cl TreeVisitor class with a depth first search @v
                visit method. That method executes either a @m pre or @m post method
                or both. In our case, we need to call @m applyOnce in both. On the way
                down, we'll look for @r vmult patterns. On the way up,
                we'll look for @r mult0 patterns.
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeParser">
            <summary>
            A parser for a stream of tree nodes.  "tree grammars" result in a subclass
            of this.  All the error reporting and recovery is shared with Parser via
            the BaseRecognizer superclass.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeParser.SetTreeNodeStream(Antlr.Runtime.Tree.ITreeNodeStream)">
            <summary>Set the input stream</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeParser.MatchAny(Antlr.Runtime.IIntStream)">
            <summary>
            Match '.' in tree parser has special meaning.  Skip node or
            entire tree if node has children.  If children, scan until
            corresponding UP node.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeParser.RecoverFromMismatchedToken(Antlr.Runtime.IIntStream,System.Int32,Antlr.Runtime.BitSet)">
            <summary>
            We have DOWN/UP nodes in the stream that have no line info; override.
            plus we want to alter the exception type.  Don't try to recover
            from tree parser errors inline...
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeParser.GetErrorHeader(Antlr.Runtime.RecognitionException)">
            <summary>
            Prefix error message with the grammar name because message is
            always intended for the programmer because the parser built
            the input tree not the user.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeParser.GetErrorMessage(Antlr.Runtime.RecognitionException,System.String[])">
            <summary>
            Tree parsers parse nodes they usually have a token object as
            payload. Set the exception token and do the default behavior.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Debug.DebugEventSocketProxy">
            <summary>
            A proxy debug event listener that forwards events over a socket to
            a debugger (or any other listener) using a simple text-based protocol;
            one event per line.  ANTLRWorks listens on server socket with a
            RemoteDebugEventSocketListener instance.  These two objects must therefore
            be kept in sync.  New events must be handled on both sides of socket.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Debug.DebugEventSocketProxy.recognizer">
            <summary>Who am i debugging?</summary> 
        </member>
        <member name="F:Antlr.Runtime.Debug.DebugEventSocketProxy.adaptor">
            <summary>
            Almost certainly the recognizer will have adaptor set, but
            we don't know how to cast it (Parser or TreeParser) to get
            the adaptor field.  Must be set with a constructor. :(
            </summary>
        </member>
        <member name="T:Antlr.Runtime.UnwantedTokenException">
            <summary>An extra token while parsing a TokenStream</summary> 
        </member>
        <member name="T:Antlr.Runtime.Misc.ErrorManager">
            <summary>A minimal ANTLR3 error [message] manager with the ST bits</summary>
        </member>
        <member name="M:Antlr.Runtime.Misc.ErrorManager.GetLastNonErrorManagerCodeLocation(System.Exception)">
            <summary>
            Return first non ErrorManager code location for generating messages
            </summary>
            <param name="e">Current exception</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Antlr.Runtime.Debug.Profiler" -->
        <member name="F:Antlr.Runtime.Debug.Profiler.Version">
            Because I may change the stats, I need to track that for later
            computations to be consistent.
        </member>
        <member name="F:Antlr.Runtime.Debug.Profiler.parser">
            Ack, should not store parser; can't do remote stuff.  Well, we pass
            input stream around too so I guess it's ok.
        </member>
        <member name="M:Antlr.Runtime.Debug.Profiler.ExamineRuleMemoization(Antlr.Runtime.IIntStream,System.Int32,System.Int32,System.String)">
            Track memoization; this is not part of standard debug interface
            but is triggered by profiling.  Code gen inserts an override
            for this method in the recognizer, which triggers this method.
            Called from alreadyParsedRule().
        </member>
        <member name="M:Antlr.Runtime.Debug.Profiler.Memoize(Antlr.Runtime.IIntStream,System.Int32,System.Int32,System.String)">
            Warning: doesn't track success/failure, just unique recording event 
        </member>
        <member name="M:Antlr.Runtime.Debug.Profiler.LT(System.Int32,Antlr.Runtime.IToken)">
            Track refs to lookahead if in a fixed/nonfixed decision.
        </member>
        <member name="M:Antlr.Runtime.Debug.Profiler.BeginBacktrack(System.Int32)">
            Track backtracking decisions.  You'll see a fixed or cyclic decision
              and then a backtrack.
            
             		enter rule
             		...
             		enter decision
             		LA and possibly consumes (for cyclic DFAs)
             		begin backtrack level
             		mark m
             		rewind m
             		end backtrack level, success
             		exit decision
             		...
             		exit rule
        </member>
        <member name="M:Antlr.Runtime.Debug.Profiler.EndBacktrack(System.Int32,System.Boolean)">
            Successful or not, track how much lookahead synpreds use 
        </member>
        <member name="M:Antlr.Runtime.Debug.Profiler.GetNumberOfHiddenTokens(System.Int32,System.Int32)">
            Get num hidden tokens between i..j inclusive 
        </member>
        <member name="P:Antlr.Runtime.Debug.Profiler.InDecision">
            The parser is in a decision if the decision depth > 0.  This
            works for backtracking also, which can have nested decisions.
        </member>
        <member name="T:Antlr.Runtime.ParserRuleReturnScope`1">
            <summary>
              Rules that return more than a single value must return an object
              containing all the values.  Besides the properties defined in
              RuleLabelScope.predefinedRulePropertiesScope there may be user-defined
              return values.  This class simply defines the minimum properties that
              are always defined and methods to access the others that might be
              available depending on output option such as template and tree.
              </summary>
            
              <remarks>
              Note text is not an actual property of the return value, it is computed
              from start and stop using the input stream's toString() method.  I
              could add a ctor to this so that we can pass in and store the input
              stream, but I'm not sure we want to do that.  It would seem to be undefined
              to get the .text property anyway if the rule matches tokens from multiple
              input streams.
            
              I do not use getters for fields of objects that are used simply to
              group values such as this aggregate.  The getters/setters are there to
              satisfy the superclass interface.
              </remarks>
        </member>
        <member name="T:Antlr.Runtime.EarlyExitException">
            <summary>The recognizer did not match anything for a (..)+ loop.</summary> 
        </member>
        <member name="F:Antlr.Runtime.Debug.DebugEventListenerConstants.ProtocolVersion">
            <summary>Moved to version 2 for v3.1: added grammar name to enter/exit Rule</summary> 
        </member>
        <member name="F:Antlr.Runtime.Debug.DebugEventListenerConstants.True">
            <summary>Serialized version of true</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.ITreeVisitorAction">
            <summary>
            How to execute code for node t when a visitor visits node t.  Execute
            pre() before visiting children and execute post() after visiting children.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeVisitorAction.Pre(System.Object)">
            <summary>
            Execute an action before visiting children of t.  Return t or
            a rewritten t.  It is up to the visitor to decide what to do
            with the return value.  Children of returned value will be
            visited if using TreeVisitor.visit().
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeVisitorAction.Post(System.Object)">
            <summary>
            Execute an action after visiting children of t.  Return t or
            a rewritten t.  It is up to the visitor to decide what to do
            with the return value.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Debug.RemoteDebugEventSocketListener.version">
            <summary>Version of ANTLR (dictates events)</summary> 
        </member>
        <member name="F:Antlr.Runtime.Debug.RemoteDebugEventSocketListener.previousTokenIndex">
            <summary>
            Track the last token index we saw during a consume.  If same, then
            set a flag that we have a problem.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.RemoteDebugEventSocketListener.Start">
            <summary>Create a thread to listen to the remote running recognizer</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.ParseTree">
            <summary>
            A record of the rules used to match a token sequence.  The tokens
            end up as the leaves of this tree and rule nodes are the interior nodes.
            This really adds no functionality, it is just an alias for CommonTree
            that is more meaningful (specific) and holds a String to display for a node.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ParseTree.ToStringWithHiddenTokens">
            <summary>
            Emit a token and all hidden nodes before.  EOF node holds all
            hidden tokens after last real token.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ParseTree.ToInputString">
            <summary>
            Print out the leaves of this tree, which means printing original
            input back out.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.ANTLRInputStream">
            <summary>
            A kind of ReaderStream that pulls from an InputStream.
            Useful for reading from stdin and specifying file encodings etc...
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.RewriteEarlyExitException">
            <summary>No elements within a (...)+ in a rewrite rule</summary> 
        </member>
        <member name="T:Antlr.Runtime.Debug.TraceDebugEventListener">
            <summary>Print out (most of) the events... Useful for debugging, testing...</summary> 
        </member>
        <member name="F:Antlr.Runtime.TokenChannels.Default">
            <summary>
            All tokens go to the parser (unless skip() is called in that rule)
            on a particular "channel".  The parser tunes to a particular channel
            so that whitespace etc... can go to the parser on a "hidden" channel.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.TokenChannels.Hidden">
            <summary>
            Anything on different channel than DEFAULT_CHANNEL is not parsed
            by parser.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.TokenTypes.Down">
            <summary>imaginary tree navigation type; traverse "get child" link</summary> 
        </member>
        <member name="F:Antlr.Runtime.TokenTypes.Up">
            <summary>imaginary tree navigation type; finish with a child list</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tokens.Skip">
            <summary>
            In an action, a lexer rule can set token to this SKIP_TOKEN and ANTLR
            will avoid creating a token for this symbol and try to fetch another.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.RecognizerSharedState">
            <summary>
              The set of fields needed by an abstract recognizer to recognize input
              and recover from errors etc...  As a separate state object, it can be
              shared among multiple grammars; e.g., when one grammar imports another.
              </summary>
            
              <remarks>
              These fields are publically visible but the actual state pointer per
              parser is protected.
              </remarks>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.following">
            <summary>
            Track the set of token types that can follow any rule invocation.
            Stack grows upwards.  When it hits the max, it grows 2x in size
            and keeps going.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.errorRecovery">
            <summary>
            This is true when we see an error and before having successfully
            matched a token.  Prevents generation of more than one error message
            per error.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.lastErrorIndex">
            <summary>
             The index into the input stream where the last error occurred.
            	This is used to prevent infinite loops where an error is found
             but no token is consumed during recovery...another error is found,
             ad naseum.  This is a failsafe mechanism to guarantee that at least
             one token/tree node is consumed for two errors.
             </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.failed">
            <summary>
            In lieu of a return value, this indicates that a rule or token
            has failed to match.  Reset to false upon valid token match.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.syntaxErrors">
            <summary>Did the recognizer encounter a syntax error?  Track how many.</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.backtracking">
            <summary>
            If 0, no backtracking is going on.  Safe to exec actions etc...
            If >0 then it's the level of backtracking.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Antlr.Runtime.RecognizerSharedState.ruleMemo" -->
        <member name="F:Antlr.Runtime.RecognizerSharedState.token">
            <summary>
            The goal of all lexer rules/methods is to create a token object.
            This is an instance variable as multiple rules may collaborate to
            create a single token.  nextToken will return this object after
            matching lexer rule(s).  If you subclass to allow multiple token
            emissions, then set this to the last token to be matched or
            something nonnull so that the auto token emit mechanism will not
            emit another token.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.tokenStartCharIndex">
            <summary>
            What character index in the stream did the current token start at?
            Needed, for example, to get the text for current token.  Set at
            the start of nextToken.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.tokenStartLine">
            <summary>The line on which the first character of the token resides</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.tokenStartCharPositionInLine">
            <summary>The character position of first character within the line</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.channel">
            <summary>The channel number for the current token</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.type">
            <summary>The token type for the current token</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.text">
            <summary>
            You can set the text for the current token to override what is in
            the input char buffer.  Use setText() or can set this instance var.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Collections.StackList">
            <summary>
            Stack abstraction that also supports the IList interface
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Collections.StackList.Push(System.Object)">
            <summary>
            Adds an element to the top of the stack list.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Collections.StackList.Pop">
            <summary>
            Removes the element at the top of the stack list and returns it.
            </summary>
            <returns>The element at the top of the stack.</returns>
        </member>
        <member name="M:Antlr.Runtime.Collections.StackList.Peek">
            <summary>
            Removes the element at the top of the stack list without removing it.
            </summary>
            <returns>The element at the top of the stack.</returns>
        </member>
        <member name="T:Antlr.Runtime.BitSet">
            <summary>
            A stripped-down version of org.antlr.misc.BitSet that is just
            good enough to handle runtime requirements such as FOLLOW sets
            for automatic error recovery.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Antlr.Runtime.BitSet.MOD_MASK" -->
        <member name="F:Antlr.Runtime.BitSet._bits">
            <summary>The actual data bits</summary> 
        </member>
        <member name="M:Antlr.Runtime.BitSet.#ctor">
            <summary>Construct a bitset of size one word (64 bits)</summary> 
        </member>
        <member name="M:Antlr.Runtime.BitSet.#ctor(System.UInt64[])">
            <summary>Construction from a static array of longs</summary> 
        </member>
        <member name="M:Antlr.Runtime.BitSet.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>Construction from a list of integers</summary> 
        </member>
        <member name="M:Antlr.Runtime.BitSet.#ctor(System.Int32)">
            <summary>Construct a bitset given the size</summary>
            <param name="nbits">The size of the bitset in bits</param>
        </member>
        <member name="M:Antlr.Runtime.BitSet.Or(Antlr.Runtime.BitSet)">
            <summary>return this | a in a new set</summary> 
        </member>
        <member name="M:Antlr.Runtime.BitSet.Add(System.Int32)">
            <summary>or this element into this set (grow as necessary to accommodate)</summary> 
        </member>
        <member name="M:Antlr.Runtime.BitSet.GrowToInclude(System.Int32)">
            <summary>Grows the set to a larger number of bits.</summary>
            <param name="bit">element that must fit in set</param>
        </member>
        <member name="M:Antlr.Runtime.BitSet.SetSize(System.Int32)">
            <summary>Sets the size of a set.</summary>
            <param name="nwords">how many words the new set should be</param>
        </member>
        <member name="M:Antlr.Runtime.BitSet.LengthInLongWords">
            <summary>return how much space is being used by the bits array not how many actually have member bits on.</summary> 
        </member>
        <member name="M:Antlr.Runtime.BitSet.ToArray">
            Is this contained within a? 
        </member>
        <member name="T:Antlr.Runtime.Tree.RewriteRuleTokenStream">
            <summary>
            </summary>
            <remarks></remarks>
            <example></example>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleTokenStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Object)">
            <summary>
            Create a stream with one element
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleTokenStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Collections.Generic.IList{System.Object})">
            <summary>Create a stream, but feed off an existing list</summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleTokenStream.NextNode">
            <summary>
            Get next token from stream and make a node for it.
            </summary>
            <remarks>
            ITreeAdaptor.Create() returns an object, so no further restrictions possible.
            </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleTokenStream.ToTree(System.Object)">
            <summary>
            
            Don't convert to a tree unless they explicitly call NextTree().
            This way we can do hetero tree nodes in rewrite.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Debug.DebugTreeParser.dbg">
            <summary>Who to notify when events in the parser occur.</summary> 
        </member>
        <member name="F:Antlr.Runtime.Debug.DebugTreeParser.isCyclicDecision">
            <summary>
            Used to differentiate between fixed lookahead and cyclic DFA decisions
            while profiling.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.DebugTreeParser.#ctor(Antlr.Runtime.Tree.ITreeNodeStream,Antlr.Runtime.Debug.IDebugEventListener,Antlr.Runtime.RecognizerSharedState)">
            <summary>
            Create a normal parser except wrap the token stream in a debug
            proxy that fires consume events.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.DebugTreeParser.SetDebugListener(Antlr.Runtime.Debug.IDebugEventListener)">
            <summary>
            Provide a new debug event listener for this parser.  Notify the
            input stream too that it should send events to this listener.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Debug.DebugEventHub">
            <summary>
              Broadcast debug events to multiple listeners.  Lets you debug and still
              use the event mechanism to build parse trees etc...  Not thread-safe.
              Don't add events in one thread while parser fires events in another.
              </summary>
            
              <seealso cref="T:Antlr.Runtime.Debug.DebugEventRepeater"/>
        </member>
        <member name="M:Antlr.Runtime.Debug.DebugEventHub.AddListener(Antlr.Runtime.Debug.IDebugEventListener)">
            <summary>
            Add another listener to broadcast events too.  Not thread-safe.
            Don't add events in one thread while parser fires events in another.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Debug.DebugTreeNodeStream">
            <summary>
            Debug any tree node stream.  The constructor accepts the stream
            and a debug listener.  As node stream calls come in, debug events
            are triggered.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Debug.DebugTreeNodeStream.lastMarker">
            <summary>Track the last mark() call result value for use in rewind().</summary> 
        </member>
        <member name="P:Antlr.Runtime.Debug.DebugTreeNodeStream.UniqueNavigationNodes">
            <summary>
            It is normally this object that instructs the node stream to
            create unique nav nodes, but to satisfy interface, we have to
            define it.  It might be better to ignore the parameter but
            there might be a use for it later, so I'll leave.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Debug.DebugParser.dbg">
            <summary>Who to notify when events in the parser occur.</summary> 
        </member>
        <member name="F:Antlr.Runtime.Debug.DebugParser.isCyclicDecision">
            <summary>
            Used to differentiate between fixed lookahead and cyclic DFA decisions
            while profiling.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.DebugParser.#ctor(Antlr.Runtime.ITokenStream,Antlr.Runtime.Debug.IDebugEventListener,Antlr.Runtime.RecognizerSharedState)">
            <summary>
            Create a normal parser except wrap the token stream in a debug
            proxy that fires consume events.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.DebugParser.SetDebugListener(Antlr.Runtime.Debug.IDebugEventListener)">
            <summary>
            Provide a new debug event listener for this parser.  Notify the
            input stream too that it should send events to this listener.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.IAstRuleReturnScope`1">
            <summary>AST rules have trees</summary> 
        </member>
        <member name="P:Antlr.Runtime.IAstRuleReturnScope`1.Tree">
            <summary>Has a value potentially if output=AST;</summary> 
        </member>
        <member name="T:Antlr.Runtime.Lexer">
            <summary>
            A lexer is recognizer that draws input symbols from a character stream.
            lexer grammars result in a subclass of this object. A Lexer object
            uses simplified match() and error recovery mechanisms in the interest
            of speed.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Lexer.input">
            <summary>Where is the lexer drawing characters from?</summary> 
        </member>
        <member name="M:Antlr.Runtime.Lexer.NextToken">
            <summary>Return a token from this source; i.e., match a token on the char stream.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Lexer.Skip">
            <summary>
            Instruct the lexer to skip creating a token for current lexer rule
            and look for another token.  nextToken() knows to keep looking when
            a lexer rule finishes with token set to SKIP_TOKEN.  Recall that
            if token==null at end of any token rule, it creates one for you
            and emits it.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Lexer.mTokens">
            <summary>This is the lexer entry point that sets instance var 'token'</summary> 
        </member>
        <member name="M:Antlr.Runtime.Lexer.Emit(Antlr.Runtime.IToken)">
            <summary>
            Currently does not support multiple emits per nextToken invocation
            for efficiency reasons.  Subclass and override this method and
            nextToken (to push tokens into a list and pull from that list rather
            than a single variable as this implementation does).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Lexer.Emit">
            <summary>
              The standard method called to automatically emit a token at the
              outermost lexical rule.  The token object should point into the
              char buffer start..stop.  If there is a text override in 'text',
              use that to set the token's text.  Override this method to emit
              custom Token objects.
              </summary>
            
              <remarks>
              If you are building trees, then you should also override
              Parser or TreeParser.getMissingSymbol().
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Lexer.Recover(Antlr.Runtime.RecognitionException)">
            <summary>
            Lexers can normally match any char in it's vocabulary after matching
            a token, so do the easy thing and just kill a character and hope
            it all works out.  You can instead use the rule invocation stack
            to do sophisticated error recovery if you are in a fragment rule.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Lexer.CharIndex">
            <summary>What is the index of the current character of lookahead?</summary> 
        </member>
    </members>
</doc>
